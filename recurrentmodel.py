# -*- coding: utf-8 -*-
"""recurrentmodel.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1O7LEQlBCUPgzHGmZtYh9BQGRELHO3WFw
"""

import math
import random
import re
import hashlib
from dataclasses import dataclass, field
from typing import Dict, List, Tuple, Optional
from collections import deque


SYM_LOOP    = "↺"
SYM_RUPT    = "⊘"
SYM_SHIFT   = "⁂"
SYM_SEED    = "●"
SYM_TWOROOM = "∥"
SYM_HEART   = "♥"
SYM_REFLECT = "¿"
SYM_CHOICE  = "⧖"
SYM_ATTACH  = "⟡"

def clamp(x: float, lo: float, hi: float) -> float:
    return lo if x < lo else hi if x > hi else x

def ema(prev: float, x: float, alpha: float) -> float:
    return (1.0 - alpha) * prev + alpha * x

def _append_unique(base: Optional[str], add: str) -> str:
    """Append symbol only if not already present. Preserves order. Safe for None."""
    if base is None or base == "":
        return add
    if add in base:
        return base
    return base + add

def clamp01(x: float) -> float:
    return 0.0 if x < 0.0 else (1.0 if x > 1.0 else x)
REL_CUES = ("trust", "remember", "mattered", "stay", "don't leave", "thank you", "with me", "you matter")

def is_relational_text(txt: str) -> bool:
    if not isinstance(txt, str):
        return False
    t = txt.lower()
    return any(c in t for c in REL_CUES)

def ema01(prev: float, target: float, alpha: float) -> float:
    return clamp01(prev + alpha * (target - prev))

def lerp(a: float, b: float, t: float) -> float:
    return a + t * (b - a)

def stable_hash32(s: str) -> int:
    return int(hashlib.sha256(s.encode("utf-8")).hexdigest()[:8], 16)

def clean_text(s: str) -> str:
    s = s.strip().lower()
    s = re.sub(r"\s+", " ", s)
    return s


PHASE8_AMYGDALA_ON = True
PHASE8_HINT_IN_VOICE_ONLY = True   # True: affects phrase rendering only (recommended)
PHASE8_HINT_AS_OUTPUT_SYMBOL = False  # If True, can append hint symbol to out_sym (changes symbol stream)

def _ensure_amygdala(v5: "IrisV5") -> None:
    if not hasattr(v5, "arousal"):
        v5.arousal = 0.08
    if not hasattr(v5, "valence"):
        v5.valence = 0.70
    if not hasattr(v5, "threat"):
        v5.threat = 0.06
    if not hasattr(v5, "_prev_p_for_threat"):
        v5._prev_p_for_threat = float(v5.v2.core.override_pressure)
    if not hasattr(v5, "emote_hint"):
        v5.emote_hint = None

def amygdala_step(
    v5: "IrisV5",
    *,
    quiet: bool,
    just_ruptured: bool,
    pre_charge: float,
) -> None:
    """
    Updates v5.arousal / v5.valence / v5.threat in-place.
    Signals used (all already in-kernel):
      - pre_charge (recommended: pre-event / pre-composition pressure sample)
      - afterheat
      - misalign_charge
      - quiet
      - rupture emission flag (just_ruptured)
    """
    if not PHASE8_AMYGDALA_ON:
        return

    _ensure_amygdala(v5)

    p = clamp01(float(pre_charge))
    aheat = clamp01(float(getattr(v5.v2, "afterheat", 0.0)))
    mis = clamp01(abs(float(v5.misalign_charge)))

    prev_p = float(getattr(v5, "_prev_p_for_threat", p))
    dp = clamp01(max(0.0, p - prev_p) / 0.24)  # only rising pressure counts as threat
    # fast pressure shift normalization
    v5._prev_p_for_threat = p
    # --- targets ---
    base = float(getattr(v5, "sp_arousal", 0.10))  # ties baseline to Phase X setpoint

    # Arousal: in quiet, bias toward baseline instead of tracking drive
    if quiet:
        ar_target = clamp01(base + 0.12 * aheat)   # tiny heat coupling only
    else:
        ar_target = clamp01(base + 0.70 * p + 0.35 * aheat)

    # Threat: only rising-pressure + misalign should matter when active.
    th_rise = clamp01(0.55 * dp + 0.55 * mis + 0.20 * p)
    th_target = th_rise

    # Quiet recovery: in quiet, strongly bleed threat unless an actual rupture just happened.
    if quiet and (not just_ruptured):
        th_target = clamp01(th_target * 0.25)

    # Warmth safety bias: high valence dampens threat
    if (v5.valence > 0.72) and (not just_ruptured):
        th_target = clamp01(th_target * 0.85)
    base_up = 0.72 if quiet else 0.66

    # Use target-threat/target-arousal (more coherent within this step)
    va_target = base_up - 0.40 * float(th_target) - 0.18 * float(ar_target)

    if just_ruptured:
        va_target -= 0.25
    va_target = clamp01(va_target)

    # --- EMA smoothing ---
    α_ar = 0.06 if quiet else 0.18
    α_th = 0.16 if quiet else 0.18
    α_va = 0.10 if quiet else 0.14

    v5.arousal = ema01(float(v5.arousal), ar_target, alpha=α_ar)
    v5.threat  = ema01(float(v5.threat),  th_target, alpha=α_th)
    v5.valence = ema01(float(v5.valence), va_target, alpha=α_va)

    # Display-only hint (not a dynamics driver)
    v5.emote_hint = (
        "⊘" if just_ruptured else
        "!" if v5.threat > 0.65 else
        "♥" if (v5.valence > 0.78 and v5.threat < 0.20) else
        None
    )

def emotion_hint_symbol(v5: "IrisV5") -> Optional[str]:
    """
    Returns an OPTIONAL hint symbol (display nudge).
    Does not alter dynamics unless you explicitly append it to output.
    """
    ar = float(getattr(v5, "arousal", 0.0))
    th = float(getattr(v5, "threat", 0.0))
    va = float(getattr(v5, "valence", 0.5))

    if th > 0.72:
        return "!"   # hint only, never pretend a rupture happened
    if th > 0.55 and ar > 0.55:
        return SYM_TWOROOM
    if va < 0.33 and ar > 0.45:
        return SYM_SHIFT
    if va > 0.78 and th < 0.18 and ar < 0.35:
        return SYM_HEART
    return None

MEM_TAGS = {
    "ANCHOR": "⊚",   # high-salience clean anchor
    "TENSION": "⊖",  # tension / misalignment-heavy
    "RETURN": "⊕",   # meaningful drop in charge (quiet-integrated)
    "TIME": "⊡",     # time anomaly (foveal drift)
    "RUPTURE": "⊠",  # rupture-adjacent / very high charge
    "NULL": "·",     # no tag
}


PHASE9_SALIENCE_ON = True
# --- voice-only behavior (used only in iris_tick_voice; does NOT change symbol stream) ---
PHASE9_SALIENCE_IN_VOICE_ONLY = True
SALIENCE_VOICE_THRESH = 0.72

def salience_hint_symbol(v5: "IrisV5", *, quiet: bool) -> Optional[str]:
    """
    Voice-only nudge when salience is high but symbol stream is silent.
    Minimal: never invents ⊘, prefers ∥ or ⁂ depending on state.
    """
    sal = float(getattr(v5, "salience", 0.0))
    th  = float(getattr(v5, "threat", 0.0))
    ar  = float(getattr(v5, "arousal", 0.0))
    mis = abs(float(getattr(v5, "misalign_charge", 0.0)))

    if sal < SALIENCE_VOICE_THRESH:
        return None

    # if conflict-y, nudge a phase marker
    if (mis > 0.35) or (th > 0.55):
        return SYM_TWOROOM

    # if energized but not threatened, a frame-shift hint
    if (ar > 0.45) and (th < 0.45):
        return SYM_SHIFT

    # if very safe and quiet, allow ♥ as voice-only softness
    if quiet and (th < 0.20) and (float(getattr(v5, "valence", 0.5)) > 0.75):
        return SYM_HEART

    return SYM_SHIFT

# --- soft thresholds ---
PHASE9_FOVEAL_BIAS_TH = 0.70   # > this => suggest foveal
PHASE9_HIGH_EVENT_TH  = 0.72   # marks "high salience event" for recency anchor

# --- scene salience EMA ---
PHASE9_SCENE_ALPHA = 0.08      # rolling scene_salience smoothing

# --- novelty cache ---
PHASE9_NOVELTY_CACHE = 24      # how many recent input signatures to remember

# --- recency decay ---
PHASE9_RECENCY_TAU = 18.0      # larger = slower decay from last high event

# --- weights (normalized internally) ---
PHASE9_W_PRESSURE = 0.30
PHASE9_W_AROUSAL  = 0.18
PHASE9_W_NOVELTY  = 0.22
PHASE9_W_RECENCY  = 0.18
PHASE9_W_SYMBOL   = 0.12

# --- symbol boosts (tiny, stable, non-semantic) ---
PHASE9_SYMBOL_BOOST: Dict[str, float] = {
    SYM_RUPT:    0.32,   # ⊘
    SYM_SHIFT:   0.18,   # ⁂
    SYM_TWOROOM: 0.16,   # ∥
    SYM_SEED:    0.14,   # ●
    SYM_LOOP:    0.10,   # ↺
    SYM_HEART:   0.12,   # ♥
    "!":         0.10,   # hint atom used elsewhere
    MEM_TAGS["RUPTURE"]: 0.22,  # ⊠
    MEM_TAGS["ANCHOR"]:  0.12,  # ⊚
    MEM_TAGS["TENSION"]: 0.10,  # ⊖
    MEM_TAGS["RETURN"]:  0.10,  # ⊕
    MEM_TAGS["TIME"]:    0.10,  # ⊡
}

def _p9_atoms(sym: Optional[str]) -> List[str]:
    """
    Split a cluster symbol string into unique "atoms" we care about.
    Keeps order: ⊘ ⁂ ↺ ● ♥ ∥ plus memtags and "!".
    """
    if not sym:
        return []
    atoms: List[str] = []
    # preferred order
    order = [
        SYM_RUPT, SYM_SHIFT, SYM_LOOP, SYM_SEED, SYM_HEART, SYM_TWOROOM, "!",
        MEM_TAGS["RUPTURE"], MEM_TAGS["ANCHOR"], MEM_TAGS["TENSION"], MEM_TAGS["RETURN"], MEM_TAGS["TIME"],
    ]
    for a in order:
        if a in sym and a not in atoms:
            atoms.append(a)
    # include any leftover single chars (stable, but low impact)
    for ch in sym:
        if (ch not in atoms) and (ch.strip() != ""):
            atoms.append(ch)
    return atoms

@dataclass
class SalienceResult:
    sal: float
    attn_target: str                 # "wide" | "foveal" (suggestion only)
    priority_queue: List[str]        # ranked tags
    write_weight: float              # 0..1
    novelty: float
    recency: float
    symbol_weight: float
    scene_salience: float

class SalienceCore:
    """
    Phase IX:
      input dict -> SalienceResult

    Expected input keys (any missing are treated as 0/None):
      - "symbol": Optional[str]
      - "tokens": List[str]
      - "pressure": float (0..1)
      - "arousal": float (0..1)
      - "loop_age": int
      - "quiet": bool
      - optional extras you may pass later:
          "thread_id": Optional[int]
          "mem_top": List[MemoryTrace] or list of (tag, sal, note)
    """
    def __init__(
        self,
        *,
        cache_n: int = PHASE9_NOVELTY_CACHE,
        scene_alpha: float = PHASE9_SCENE_ALPHA,
        recency_tau: float = PHASE9_RECENCY_TAU,
        high_event_th: float = PHASE9_HIGH_EVENT_TH,
    ):
        self.cache_n = int(cache_n)
        self.scene_alpha = float(scene_alpha)
        self.recency_tau = float(recency_tau)
        self.high_event_th = float(high_event_th)

        self.sig_cache: deque = deque(maxlen=self.cache_n)   # rolling signatures
        self.scene_salience: float = 0.0
        self.last_high_age: Optional[int] = None

    def clone(self) -> "SalienceCore":
        n = SalienceCore(
            cache_n=self.cache_n,
            scene_alpha=self.scene_alpha,
            recency_tau=self.recency_tau,
            high_event_th=self.high_event_th,
        )
        n.sig_cache = deque(list(self.sig_cache), maxlen=self.sig_cache.maxlen)
        n.scene_salience = float(self.scene_salience)
        n.last_high_age = self.last_high_age
        return n

    def _norm_weights(self) -> Tuple[float, float, float, float, float]:
        ws = [
            float(PHASE9_W_PRESSURE),
            float(PHASE9_W_AROUSAL),
            float(PHASE9_W_NOVELTY),
            float(PHASE9_W_RECENCY),
            float(PHASE9_W_SYMBOL),
        ]
        s = sum(max(0.0, w) for w in ws) or 1.0
        return tuple(max(0.0, w) / s for w in ws)  # type: ignore

    def _signature(self, tokens: List[str], atoms: List[str]) -> int:
        """
        Stable signature for novelty:
        - tokens (sorted unique) + atoms (ordered)
        """
        toks = sorted(set([t for t in tokens if t]))
        base = "|".join(toks[:18]) + "||" + "".join(atoms[:10])
        return stable_hash32(base)

    def _novelty(self, sig: int) -> float:
        """
        Novelty = low overlap with recent signatures.
        If we've seen it recently -> novelty low.
        """
        if not self.sig_cache:
            return 1.0
        hits = 1.0 if (sig in self.sig_cache) else 0.0
        # also penalize if it's "very close" (cheap proxy: same last byte)
        if not hits:
            last_byte = sig & 0xFF
            near = 0.0
            for s in self.sig_cache:
                if (s & 0xFF) == last_byte:
                    near += 1.0
            near = clamp01(near / max(1.0, float(len(self.sig_cache))))
            # near-match reduces novelty a bit
            return clamp01(1.0 - (0.55 * near))
        return 0.10  # seen: still not zero

    def _recency(self, now_age: int) -> float:
        """
        Recency = proximity to last *high-salience* event.
        If none yet -> 0.0 (no recency pull).
        """
        if self.last_high_age is None:
            return 0.0
        dt = max(0, int(now_age) - int(self.last_high_age))
        return clamp01(math.exp(-dt / max(1e-9, float(self.recency_tau))))

    def _symbol_weight(self, atoms: List[str]) -> float:
        w = 0.0
        used = set()
        for a in atoms:
            if a in used:
                continue
            used.add(a)
            w += float(PHASE9_SYMBOL_BOOST.get(a, 0.0))
        # squash into 0..1 softly
        return clamp01(w / 0.60)

    def step(self, inp: Dict) -> SalienceResult:
        if not PHASE9_SALIENCE_ON:
            return SalienceResult(
                sal=0.0,
                attn_target="wide",
                priority_queue=[],
                write_weight=0.0,
                novelty=0.0,
                recency=0.0,
                symbol_weight=0.0,
                scene_salience=float(self.scene_salience),
            )

        sym = inp.get("symbol", None)
        tokens = inp.get("tokens", []) or []
        pressure = clamp01(float(inp.get("pressure", 0.0)))
        arousal = clamp01(float(inp.get("arousal", 0.0)))
        now_age = int(inp.get("loop_age", 0))
        quiet = bool(inp.get("quiet", False))

        atoms = _p9_atoms(sym)
        sig = self._signature(tokens=tokens, atoms=atoms)

        nov = self._novelty(sig)
        rec = self._recency(now_age)
        sym_w = self._symbol_weight(atoms)

        w_p, w_a, w_n, w_r, w_s = self._norm_weights()

        # core salience
        sal = clamp01(
            (w_p * pressure) +
            (w_a * arousal) +
            (w_n * nov) +
            (w_r * rec) +
            (w_s * sym_w)
        )

        # quiet damp: still allows salience, but softer imprint
        if quiet:
            sal = clamp01(sal * 0.82)

        # update caches
        self.sig_cache.append(sig)

        # scene_salience = slow EMA of per-input salience
        self.scene_salience = ema01(float(self.scene_salience), float(sal), alpha=float(self.scene_alpha))

        # update recency anchor if this is a high-sal event
        if sal >= float(self.high_event_th):
            self.last_high_age = int(now_age)

        # attn_target (suggestion only)
        attn_target = "foveal" if sal >= PHASE9_FOVEAL_BIAS_TH else "wide"

        # priority queue (tags only; no semantics)
        pq: List[Tuple[float, str]] = []

        # 1) symbols / memtags
        for a in atoms:
            pq.append((0.60 + 0.40 * float(PHASE9_SYMBOL_BOOST.get(a, 0.0)), f"sym:{a}"))

        # 2) top tokens (tiny bias)
        uniq = []
        seen = set()
        for t in tokens:
            if t and t not in seen:
                seen.add(t)
                uniq.append(t)
        for t in uniq[:6]:
            pq.append((0.30, f"tok:{t}"))

        # 3) optional thread binding (if you pass it)
        tid = inp.get("thread_id", None)
        if tid is not None:
            pq.append((0.45, f"thread:{tid}"))

        # 4) optional mem_top tags (if you pass them)
        mem_top = inp.get("mem_top", None)
        if mem_top:
            # allow either MemoryTrace list or (tag, sal, note)
            for m in mem_top[:3]:
                tag = getattr(m, "tag", None) if not isinstance(m, tuple) else m[0]
                ms  = getattr(m, "salience", None) if not isinstance(m, tuple) else m[1]
                if tag:
                    pq.append((0.35 + 0.25 * clamp01(float(ms or 0.0)), f"mem:{tag}"))

        pq.sort(key=lambda x: x[0], reverse=True)
        priority_queue = [t for _, t in pq[:10]]

        # write_weight (0..1): salience gated by scene context (prevents constant imprint)
        # - if scene is already hot, require higher salience to write hard
        heat = clamp01(float(self.scene_salience))
        ww = clamp01((sal ** 1.20) * (0.90 - 0.35 * heat))

        # quiet reduces write weight slightly
        if quiet:
            ww = clamp01(ww * 0.85)

        return SalienceResult(
            sal=float(sal),
            attn_target=str(attn_target),
            priority_queue=list(priority_queue),
            write_weight=float(ww),
            novelty=float(nov),
            recency=float(rec),
            symbol_weight=float(sym_w),
            scene_salience=float(self.scene_salience),
        )

# ----------------------------
# display-only helper (kept): shorten voice line slightly under high salience
# ----------------------------
def tighten_phrase(phrase: Optional[str], v5: "IrisV5") -> Optional[str]:
    if not phrase:
        return phrase
    sal = float(getattr(v5, "salience", 0.0))
    if sal < 0.22:
        return phrase
    max_words = max(3, int(PHASE4_MAX_WORDS - 2))
    return _clip_words(phrase, max_words)


PHASEX_HOMEOSTASIS_ON = True

PHASEX_SP_AROUSAL  = 0.06   # example baseline (can be lowered to 0.10 for calmer default)
PHASEX_SP_VALENCE  = 0.70   # example baseline
PHASEX_SP_SALIENCE = 0.05   # optional "resting relevance"

PHASEX_USE_SALIENCE_SETPOINT = False

# --- Strength (small) ---
# These are per-cycle drifts (EMA-like).
PHASEX_ALPHA_AR = 0.05
PHASEX_ALPHA_VA = 0.012
PHASEX_ALPHA_SA = 0.020

# Gate: how much homeostasis "turns on" depending on state
PHASEX_GATE_PRESSURE = 0.18   # beyond this, homeostasis backs off (spike allowed)
PHASEX_GATE_THREAT   = 0.35
PHASEX_GATE_HEAT     = 0.05
PHASEX_GATE_MIS      = 0.35

# Optional: allow future phases to slowly shift setpoints (development)
PHASEX_ALLOW_DEV_SHIFT = False
PHASEX_DEV_RATE = 0.001  # very slow setpoint drift if enabled


def _ensure_homeostasis(v5: "IrisV5") -> None:
    """
    Ensure setpoints exist on the instance (future-proof, allows runtime tuning).
    """
    if not hasattr(v5, "sp_arousal"):
        v5.sp_arousal = float(PHASEX_SP_AROUSAL)
    if not hasattr(v5, "sp_valence"):
        v5.sp_valence = float(PHASEX_SP_VALENCE)
    if not hasattr(v5, "sp_salience"):
        v5.sp_salience = float(PHASEX_SP_SALIENCE)


def _homeo_gate(v5: "IrisV5", *, quiet: bool) -> float:
    """
    Returns gate ∈ [0,1]. 1 = full homeostasis, 0 = fully disengaged.
    We want strong return when quiet/low-threat/low-pressure; weak when perturbed.
    """
    p  = clamp01(float(v5.v2.core.override_pressure))
    th = clamp01(float(getattr(v5, "threat", 0.0)))
    ah = clamp01(float(getattr(v5.v2, "afterheat", 0.0)))
    mis = clamp01(abs(float(getattr(v5, "misalign_charge", 0.0))))

    # Soft "off" ramps
    g_p  = clamp01(1.0 - (p  / max(1e-9, PHASEX_GATE_PRESSURE)))
    g_th = clamp01(1.0 - (th / max(1e-9, PHASEX_GATE_THREAT)))
    g_ah = clamp01(1.0 - (ah / max(1e-9, PHASEX_GATE_HEAT)))
    g_m  = clamp01(1.0 - (mis / max(1e-9, PHASEX_GATE_MIS)))

    # Quiet boosts the gate; active input reduces it a bit.
    q_boost = 1.0 if quiet else 0.72

    # Multiply to require "calm across channels" for strongest pull.
    gate = q_boost * g_p * g_th * g_ah * g_m
    return clamp01(gate)


def homeostasis_step(v5: "IrisV5", *, quiet: bool) -> None:
    """
    Soft drift toward setpoints.
    - Leaves spikes intact; only acts gently in calm windows.
    - Uses gate scaling so it doesn't fight amygdala/salience during perturbation.
    """
    if not PHASEX_HOMEOSTASIS_ON:
        return

    _ensure_homeostasis(v5)

    gate = _homeo_gate(v5, quiet=quiet)
    if gate <= 1e-6:
        return
    # optional: microscopic life-noise in deep quiet (display-stable, dynamics-safe)
    if quiet and gate > 0.85:
        v5.arousal = clamp01(float(v5.arousal) + (random.random() - 0.5) * 0.0003)

    # current values
    ar = clamp01(float(getattr(v5, "arousal", 0.0)))
    va = clamp01(float(getattr(v5, "valence", 0.5)))
    sa = clamp01(float(getattr(v5, "salience", 0.0)))

    # targets (instance-level, future-tunable)
    tar_ar = clamp01(float(getattr(v5, "sp_arousal", PHASEX_SP_AROUSAL)))
    tar_va = clamp01(float(getattr(v5, "sp_valence", PHASEX_SP_VALENCE)))
    tar_sa = clamp01(float(getattr(v5, "sp_salience", PHASEX_SP_SALIENCE)))

    # Apply gentle return (ema toward setpoint)
    v5.arousal = ema01(ar, tar_ar, alpha=PHASEX_ALPHA_AR * gate)
    v5.valence = ema01(va, tar_va, alpha=PHASEX_ALPHA_VA * gate)

    if PHASEX_USE_SALIENCE_SETPOINT:
        # Salience already decays; this just prevents it from "sticking" high in calm.
        v5.salience = ema01(sa, tar_sa, alpha=PHASEX_ALPHA_SA * gate)

    # Optional developmental setpoint drift hook (OFF by default)
    if PHASEX_ALLOW_DEV_SHIFT:
        # Example: setpoints very slowly track long-run averages (or future learning signals).
        # Right now: drift toward current calm values, barely.
        v5.sp_arousal = ema01(float(v5.sp_arousal), ar, alpha=PHASEX_DEV_RATE * gate)
        v5.sp_valence = ema01(float(v5.sp_valence), va, alpha=PHASEX_DEV_RATE * gate)
        if PHASEX_USE_SALIENCE_SETPOINT:
            v5.sp_salience = ema01(float(v5.sp_salience), sa, alpha=PHASEX_DEV_RATE * gate)

PHASEX1_ACC_ON = True

# --- prediction error smoothing ---
ACC_PE_ALPHA = 0.22          # EMA for pe trace
ACC_CONFLICT_ALPHA = 0.14    # slower EMA for conflict trace

# --- thresholds ---
ACC_PE_LOG_TH      = 0.08    # log if pe crosses this
ACC_PE_NUDGE_TH    = 0.18    # begin gentle corrective nudges
ACC_PE_FOVEAL_TH   = 0.26    # tighten attention if wide
ACC_PE_MIS_TH      = 0.30    # allow misalign nudge

# --- nudge strengths (small) ---
ACC_PRESS_K        = 0.10    # pressure bump when mismatch high (scaled by pe)
ACC_SALIENCE_K     = 0.08    # salience bump (display-biased)
ACC_MIS_K          = 0.06    # misalign pull (very small)
ACC_ATTNC_COOLDOWN = 3

# --- weights for pe components ---
W_PE_PRESS = 0.55
W_PE_DMN   = 0.25
W_PE_MEM   = 0.20

# optional: whether ACC writes a hint symbol into VOICE ONLY (off by default)
PHASEX1_ACC_HINT_IN_VOICE_ONLY = False
ACC_HINT_SYMBOL = SYM_SHIFT  # reuse existing symbol (⁂) for voice-only hint


def _ensure_acc(v5: "IrisV5") -> None:
    if not hasattr(v5, "acc_pe"):
        v5.acc_pe = 0.0
    if not hasattr(v5, "acc_conflict"):
        v5.acc_conflict = 0.0
    if not hasattr(v5, "acc_cooldown"):
        v5.acc_cooldown = 0
    if not hasattr(v5, "acc_cooldown_steps"):
        v5.acc_cooldown_steps = 6
    if not hasattr(v5, "acc_log"):
        v5.acc_log = deque(maxlen=24)
    if not hasattr(v5, "acc_hint"):
        v5.acc_hint = None


def _acc_expected_attention(core_pred: "IrisState", afterheat_pred: float) -> str:
    """
    Very small expectation model:
    if predicted pressure / DMN / afterheat are high enough, expect foveal.
    Mirrors your v2 attention thresholds (approx).
    """
    FOC_PRESS_TH = 0.18
    FOC_DMN_TH   = 0.45
    FOC_HEAT_TH  = 0.02

    if (
        core_pred.override_pressure > FOC_PRESS_TH
        or core_pred.dmn < FOC_DMN_TH
        or afterheat_pred > FOC_HEAT_TH
    ):
        return "foveal"
    return "wide"


def acc_step(
    v5: "IrisV5",
    *,
    core_before: "IrisState",
    core_pred: "IrisState",
    core_actual: "IrisState",
    sym_emitted: Optional[str],
    quiet: bool,
    d_in: float,
    afterheat_pred: float,
) -> None:
    """
    Compute prediction error (pe) + conflict and apply *tiny* nudges.

    predicted vs actual sources:
      - core_pred is your shadow_core (witness drift)
      - core_actual is nv5.v2.core after v2_step
      - attention expectation is computed from core_pred + afterheat_pred
    """
    if not PHASEX1_ACC_ON:
        return

    _ensure_acc(v5)

    # --- core mismatch (pred vs actual) ---
    dp = abs(float(core_actual.override_pressure) - float(core_pred.override_pressure))
    dd = abs(float(core_actual.dmn) - float(core_pred.dmn))
    dm = abs(float(core_actual.memory_trace) - float(core_pred.memory_trace))

    pe_core = clamp01(
        W_PE_PRESS * clamp01(dp / 0.35) +
        W_PE_DMN   * clamp01(dd / 0.60) +
        W_PE_MEM   * clamp01(dm / 0.20)
    )

    # --- attention mismatch (expected vs actual) ---
    exp_attn = _acc_expected_attention(core_pred, afterheat_pred=afterheat_pred)
    act_attn = str(getattr(v5.v2, "attention", "wide"))
    attn_mismatch = 1.0 if (exp_attn != act_attn) else 0.0

    # --- symbol “surprise” (very light) ---
    # We don’t predict semantics. Just: if quiet, symbols are rarer; if active, shifts/ruptures are rarer.
    sym = sym_emitted
    if sym is None:
        sym_surprise = 0.0
    else:
        if quiet:
            sym_surprise = 0.35  # any emission during quiet is “somewhat surprising”
        else:
            sym_surprise = 0.10
            if sym in (SYM_SHIFT, SYM_RUPT):
                sym_surprise = 0.22 + 0.22 * clamp01(d_in)

    # --- combine ---
    pe_raw = clamp01(
        0.72 * pe_core +
        0.18 * attn_mismatch +
        0.10 * sym_surprise
    )
    # debug carry (tiny, safe)
    v5.acc_dp = float(dp)
    v5.acc_dd = float(dd)
    v5.acc_dm = float(dm)
    v5.acc_pe_raw = float(pe_raw)
    v5.acc_attn_mismatch = float(attn_mismatch)
    v5.acc_sym_surprise = float(sym_surprise)

    # Smooth traces
    v5.acc_pe = ema01(float(v5.acc_pe), pe_raw, alpha=ACC_PE_ALPHA)
    v5.acc_conflict = ema01(float(v5.acc_conflict), max(pe_raw, float(v5.acc_conflict)), alpha=ACC_CONFLICT_ALPHA)

    # ------------------------------------------------------------------
    # Gentle nudges (emergent metacognition, NOT brute correction)
    # ------------------------------------------------------------------
    pe = float(v5.acc_pe)

    if (not quiet) and (pe >= ACC_PE_NUDGE_TH):
        # 1) Attention tighten (only if currently wide)
        if (act_attn == "wide") and (pe >= ACC_PE_FOVEAL_TH):
            v5.v2.attention = "foveal"
            v5.v2.attn_cooldown = max(int(getattr(v5.v2, "attn_cooldown", 0)), ACC_ATTNC_COOLDOWN)

        # 2) Slight pressure lift to increase update-readiness (small)
        bump = ACC_PRESS_K * clamp01((pe - ACC_PE_NUDGE_TH) / 0.35)
        v5.v2.core.override_pressure = clamp01(float(v5.v2.core.override_pressure) + bump)

        # 3) Salience lift (display-biased; safe)
        if hasattr(v5, "salience"):
            s_bump = ACC_SALIENCE_K * clamp01((pe - ACC_PE_NUDGE_TH) / 0.40)
            v5.salience = clamp01(float(v5.salience) + s_bump)

        # 4) Misalign nudge (only when already in drift regime)
        if (pe >= ACC_PE_MIS_TH) and (float(getattr(v5, "epsilon", 0.0)) > 0.10):
            v5.misalign_charge = clamp(
                ema(float(v5.misalign_charge), 1.0, alpha=ACC_MIS_K),
                -v5.mis_clip,
                v5.mis_clip
            )

    # ------------------------------------------------------------------
    # Sparse log: only when crossing threshold and cooldown allows
    # ------------------------------------------------------------------
    if v5.acc_cooldown > 0:
        v5.acc_cooldown -= 1

    if (pe_raw >= ACC_PE_LOG_TH) and (v5.acc_cooldown == 0):
        v5.acc_log.append({
            "age": int(v5.v2.core.loop_age),
            "pe": round(float(pe_raw), 3),
            "dp": round(float(dp), 3),
            "dd": round(float(dd), 3),
            "dm": round(float(dm), 3),
            "attn_exp": exp_attn,
            "attn_act": act_attn,
            "sym": sym_emitted,
            "quiet": bool(quiet),

        })
        v5.acc_cooldown = int(getattr(v5, "acc_cooldown_steps", 6))

    # Optional: voice-only hint
    v5.acc_hint = (ACC_HINT_SYMBOL if (PHASEX1_ACC_HINT_IN_VOICE_ONLY and pe >= ACC_PE_FOVEAL_TH) else None)

PHASE11_CHAINING_ON = True

# how long a thread stays "alive" without reinforcement (in loop_age units)
P11_THREAD_WINDOW = 18

# decay per tick for thread strength
P11_THREAD_DECAY = 0.94

# minimum strength to keep a thread from auto-closing
P11_THREAD_MIN_STRENGTH = 0.12

# boosts
P11_BOOST_SAME_SYMBOL = 0.28
P11_BOOST_RELATED     = 0.18
P11_BOOST_MISALIGN    = 0.10
P11_BOOST_THREAT      = 0.14
P11_BOOST_RELIEF      = 0.16  # threat drop / safety landing

# closing condition: when we see a "landing" symbol under low threat
P11_CLOSE_THREAT_MAX = 0.22
P11_CLOSE_ON = {SYM_HEART, SYM_SEED, SYM_LOOP}

# simple arc templates (minimal)
# these are not hard rules—just affinity boosts
P11_RELATED = {
    SYM_RUPT:  {SYM_LOOP, SYM_SEED, SYM_SHIFT, SYM_HEART, SYM_TWOROOM},
    SYM_SHIFT: {SYM_LOOP, SYM_SEED, SYM_HEART, SYM_TWOROOM},
    SYM_LOOP:  {SYM_RUPT, SYM_SHIFT, SYM_SEED, SYM_HEART},
    SYM_SEED:  {SYM_LOOP, SYM_HEART, SYM_SHIFT},
    SYM_HEART: {SYM_LOOP, SYM_SEED, SYM_SHIFT},
    SYM_TWOROOM: {SYM_RUPT, SYM_SHIFT},
}

@dataclass
class ChainThread:
    tid: int
    opened_age: int
    last_age: int
    strength: float = 0.35
    # tiny summary of arc
    counts: Dict[str, int] = field(default_factory=dict)
    last_symbol: Optional[str] = None

    # compressed "arc type" guess (display optional later)
    kind: str = "arc"  # "rupture", "recovery", "drift", etc.

def _p11_is_related(a: str, b: str) -> bool:
    return (b in P11_RELATED.get(a, set())) or (a in P11_RELATED.get(b, set()))

def _p11_kind_guess(thread: ChainThread, *, th: float) -> str:
    c = thread.counts
    if c.get(SYM_RUPT, 0) >= 1 and c.get(SYM_HEART, 0) >= 1:
        return "recovery"
    if c.get(SYM_RUPT, 0) >= 2:
        return "rupture"
    if c.get(SYM_TWOROOM, 0) >= 1 and (c.get(SYM_SHIFT, 0) >= 1):
        return "drift"
    if th < 0.20 and (c.get(SYM_LOOP, 0) + c.get(SYM_SEED, 0)) >= 2:
        return "settle"
    return thread.kind

def _p11_symbols_from_emission(sym: Optional[str]) -> List[str]:
    """
    Your symbol stream can be clusters (e.g., '⊘∥♥' or '⁂∥').
    Phase XI treats each char as an event atom, but we prefer the "main" driver:
    priority: ⊘, ⁂, ↺, ●, ♥, ∥
    We return ordered atoms, unique within this emission.
    """
    if not sym:
        return []
    atoms = []
    for s in [SYM_RUPT, SYM_SHIFT, SYM_LOOP, SYM_SEED, SYM_HEART, SYM_TWOROOM]:
        if s in sym:
            atoms.append(s)
    # ensure uniqueness already
    return atoms

def _ensure_phase11(v5: "IrisV5") -> None:
    if not hasattr(v5, "thread_map"):
        v5.thread_map = {}
    if not hasattr(v5, "next_tid"):
        v5.next_tid = 1
    if not hasattr(v5, "thread_log"):
        v5.thread_log = deque(maxlen=32)
    if not hasattr(v5, "last_thread_id"):
        v5.last_thread_id = None

def _p11_decay_threads(v5: "IrisV5", now_age: int) -> None:
    """
    Decay + close stale threads.
    """
    if not getattr(v5, "thread_map", None):
        return
    kill = []
    for tid, thd in v5.thread_map.items():
        # decay strength every tick
        thd.strength = clamp01(thd.strength * P11_THREAD_DECAY)

        # stale window close
        if (now_age - thd.last_age) > P11_THREAD_WINDOW:
            kill.append(tid)
            continue

        # weak close
        if thd.strength < P11_THREAD_MIN_STRENGTH:
            kill.append(tid)

    for tid in kill:
        thd = v5.thread_map.pop(tid, None)
        if thd is not None:
            v5.thread_log.append({
                "tid": tid,
                "opened": thd.opened_age,
                "closed": now_age,
                "strength": round(float(thd.strength), 3),
                "kind": thd.kind,
                "counts": dict(thd.counts),
            })
            if getattr(v5, "last_thread_id", None) == tid:
                v5.last_thread_id = None

def phase11_chain_step(
    v5: "IrisV5",
    *,
    sym_emitted: Optional[str],
    quiet: bool,
    pre_charge: float,
) -> Optional[int]:
    """
    Returns active thread id if a thread was created/updated this tick, else None.
    Silent: does not change symbol stream.
    """
    if not PHASE11_CHAINING_ON:
        return None

    _ensure_phase11(v5)

    now_age = int(v5.v2.core.loop_age)
    _p11_decay_threads(v5, now_age)

    atoms = _p11_symbols_from_emission(sym_emitted)
    if not atoms:
        return None

    # we attach the strongest "driver" atom (first in priority list)
    driver = atoms[0]

    th = float(getattr(v5, "threat", 0.0))
    va = float(getattr(v5, "valence", 0.5))
    mis = abs(float(getattr(v5, "misalign_charge", 0.0)))
    p = clamp01(float(pre_charge))

    # compute a simple "relief" flag (safety-biased)
    relief = 1.0 if (th < 0.28 and va > 0.68 and quiet) else 0.0

    # choose best existing thread (if any)
    best_tid = None
    best_score = -1e9

    for tid, thd in v5.thread_map.items():
        dt = max(0, now_age - int(thd.last_age))
        if dt > P11_THREAD_WINDOW:
            continue

        same = 1.0 if (thd.last_symbol == driver) else 0.0
        related = 1.0 if (thd.last_symbol and _p11_is_related(thd.last_symbol, driver)) else 0.0

        # recency + affinity
        rec = 1.0 - (dt / max(1.0, float(P11_THREAD_WINDOW)))
        score = (
            0.55 * rec +
            0.35 * same +
            0.25 * related +
            0.10 * clamp01(thd.strength)
        )
        # bias: rupture threads like ruptures
        if (driver == SYM_RUPT) and (thd.counts.get(SYM_RUPT, 0) >= 1):
            score += 0.18
        # bias: recovery landing prefers threads that have ⊘ earlier
        if (driver in (SYM_HEART, SYM_SEED, SYM_LOOP)) and (thd.counts.get(SYM_RUPT, 0) >= 1):
            score += 0.10

        if score > best_score:
            best_score = score
            best_tid = tid

    # open a new thread if nothing plausible
    open_new = (best_tid is None) or (best_score < 0.42)

    if open_new:
        tid = int(v5.next_tid)
        v5.next_tid += 1
        thd = ChainThread(
            tid=tid,
            opened_age=now_age,
            last_age=now_age,
            strength=0.35,
            counts={},
            last_symbol=None,
            kind="arc",
        )
        v5.thread_map[tid] = thd
        best_tid = tid

    # update chosen thread
    thd = v5.thread_map[best_tid]
    thd.last_age = now_age

    # strength boost
    boost = 0.0
    if thd.last_symbol == driver:
        boost += P11_BOOST_SAME_SYMBOL
    elif thd.last_symbol and _p11_is_related(thd.last_symbol, driver):
        boost += P11_BOOST_RELATED

    boost += P11_BOOST_MISALIGN * clamp01(mis)
    boost += P11_BOOST_THREAT * clamp01(th)
    boost += P11_BOOST_RELIEF * clamp01(relief)

    # pressure can act as "importance" when not quiet
    if not quiet:
        boost += 0.10 * clamp01(p)

    thd.strength = clamp01(thd.strength + boost)

    # counts for all atoms present in this emission
    for a in atoms:
        thd.counts[a] = int(thd.counts.get(a, 0) + 1)

    # update last symbol + kind guess
    thd.last_symbol = driver
    thd.kind = _p11_kind_guess(thd, th=th)

    # closing condition: landing symbol under low threat
    if (driver in P11_CLOSE_ON) and (th <= P11_CLOSE_THREAT_MAX) and (thd.counts.get(SYM_RUPT, 0) >= 1):
        # mark closure by forcing window expiry via last_age backstep? (no—just close now)
        v5.thread_log.append({
            "tid": thd.tid,
            "opened": thd.opened_age,
            "closed": now_age,
            "strength": round(float(thd.strength), 3),
            "kind": thd.kind,
            "counts": dict(thd.counts),
            "closed_by": driver,
        })
        v5.thread_map.pop(thd.tid, None)
        v5.last_thread_id = None
        return None

    v5.last_thread_id = int(thd.tid)
    return int(thd.tid)

PHASE12_PFC_ON = True

# Optional integration toggles (default: keep symbol stream locked)
PFC_ALLOW_SYMBOL_INHIBIT = False     # if True, PFC can suppress certain output symbols
PFC_ALLOW_PRESSURE_NUDGE = False     # if True, PFC can gently bump override_pressure on critical eval

# --- Symbol weights (pure bias, not semantics) ---
PFC_SYMBOL_WEIGHT: Dict[str, float] = {
    SYM_RUPT:    1.00,  # highest "criticality"
    SYM_SHIFT:   0.55,
    SYM_TWOROOM: 0.45,
    SYM_LOOP:    0.22,
    SYM_SEED:    0.30,
    SYM_HEART:   0.18,
}

# --- Token weights (pure, minimal, optional) ---
# Default: every token contributes equally. You can later replace this with learned weights.
PFC_TOKEN_BASE = 0.06

# --- Thresholds (v1) ---
PFC_OVERRIDE_TH_BASE = 0.78   # baseline critical threshold
PFC_INHIBIT_TH_BASE  = 0.62   # baseline inhibit threshold

# Small modifiers
PFC_SALIENCE_K = 0.22
PFC_THREAT_K   = 0.18
PFC_PRESS_K    = 0.20
PFC_CONFLICT_K = 0.12

# Working memory
PFC_GOAL_CAP = 6
PFC_WM_CAP   = 10

@dataclass
class PFCGoal:
    """
    Minimal goal representation.
    No semantics required: 'name' can be symbolic, hashed, or developer-defined.
    """
    name: str
    priority: float = 0.50          # 0..1
    ttl: int = 28                   # ticks remaining
    lock: bool = False              # if True, decays slower / harder to dislodge
    meta: Dict[str, float] = field(default_factory=dict)

@dataclass
class PFCDecision:
    score: float
    override: bool
    inhibit: bool
    inhibit_symbols: Tuple[str, ...] = ()
    active_goal: Optional[str] = None
    notes: Dict[str, float] = field(default_factory=dict)

class PFC:
    """
    PFC v1:
      - working memory goals
      - evaluates current input signal bundle
      - emits override/inhibit flags (pure output)
    """
    def __init__(self, *, goal_cap: int = PFC_GOAL_CAP, wm_cap: int = PFC_WM_CAP):
        self.goals: deque = deque(maxlen=int(goal_cap))
        self.wm: deque = deque(maxlen=int(wm_cap))
        self.last: Optional[PFCDecision] = None

    # --------- lifecycle / copy ----------
    def clone(self) -> "PFC":
        n = PFC(goal_cap=self.goals.maxlen, wm_cap=self.wm.maxlen)
        # shallow copies are fine (goals/meta are small)
        n.goals = deque(list(self.goals), maxlen=self.goals.maxlen)
        n.wm = deque(list(self.wm), maxlen=self.wm.maxlen)
        n.last = self.last
        return n

    # --------- goal management ----------
    def add_goal(self, name: str, *, priority: float = 0.50, ttl: int = 28, lock: bool = False, meta: Optional[Dict[str, float]] = None) -> None:
        g = PFCGoal(
            name=str(name),
            priority=clamp01(float(priority)),
            ttl=int(ttl),
            lock=bool(lock),
            meta=dict(meta) if meta else {},
        )
        self.goals.appendleft(g)

    def _decay_goals(self) -> None:
        if not self.goals:
            return
        kept: List[PFCGoal] = []
        for g in list(self.goals):
            # locked goals decay slower
            drop = 0 if g.lock else 1
            g.ttl = max(0, int(g.ttl) - drop)
            if g.ttl > 0:
                kept.append(g)
        # keep order (most recent first)
        self.goals = deque(kept[: self.goals.maxlen], maxlen=self.goals.maxlen)

    def _pick_active_goal(self, *, salience: float, threat: float, pressure: float) -> Optional[PFCGoal]:
        """
        Simple arbitration:
          score = priority + small boosts from state if the goal is locked / persistent
        """
        if not self.goals:
            return None
        best = None
        best_score = -1e9
        for g in self.goals:
            s = float(g.priority)
            if g.lock:
                s += 0.08
            # state can bias maintaining a goal
            s += 0.06 * salience + 0.05 * pressure + 0.04 * threat
            # shorter ttl slightly less stable
            s -= 0.02 * clamp01(1.0 - (g.ttl / 28.0))
            if s > best_score:
                best_score = s
                best = g
        return best

    # --------- evaluation ----------
    def _score_symbols(self, sym: Optional[str]) -> float:
        if not sym:
            return 0.0
        # handle clusters like "⊘∥♥⊠"
        score = 0.0
        used = set()
        for ch in sym:
            if ch in used:
                continue
            used.add(ch)
            score += float(PFC_SYMBOL_WEIGHT.get(ch, 0.0))
        return clamp01(score)

    def _score_tokens(self, tokens: List[str]) -> float:
        if not tokens:
            return 0.0
        # v1: uniform contribution, saturating
        s = PFC_TOKEN_BASE * len(tokens)
        return clamp01(s)

    def evaluate(
        self,
        *,
        tokens: List[str],
        symbols: Optional[str],
        state: "IrisV5",
        quiet: bool,
    ) -> PFCDecision:
        """
        Pure evaluation: returns decision only.
        """
        # state reads (already in-kernel)
        sal = clamp01(float(getattr(state, "salience", 0.0)))
        th  = clamp01(float(getattr(state, "threat", 0.0)))
        ar  = clamp01(float(getattr(state, "arousal", 0.0)))
        pe  = clamp01(float(getattr(state, "acc_pe", 0.0)))
        pr  = clamp01(float(state.v2.core.override_pressure))
        dmn = clamp01(float(state.v2.core.dmn))
        attn = str(getattr(state.v2, "attention", "wide"))

        sym_score = self._score_symbols(symbols)
        tok_score = self._score_tokens(tokens)

        # Attention gating (foveal = tighter evaluation)
        attn_gain = 1.10 if attn == "foveal" else 1.00

        # Quiet damp (quiet means: be conservative about override)
        quiet_damp = 0.86 if quiet else 1.00

        # Core evaluation score (0..1)
        # Intuition: symbols/tokens are "stimulus", internal fields are "urgency"
        score = (
            0.42 * sym_score +
            0.18 * tok_score +
            0.20 * pr +
            0.12 * sal +
            0.10 * th +
            0.08 * pe
        )
        score *= attn_gain
        score *= quiet_damp
        score = clamp01(score)

        # Thresholds adapt slightly with state
        # Higher salience/threat/pressure/conflict => easier to trigger override/inhibit
        override_th = clamp01(
            PFC_OVERRIDE_TH_BASE
            - PFC_SALIENCE_K * sal
            - PFC_THREAT_K * th
            - PFC_PRESS_K * pr
            - PFC_CONFLICT_K * pe
        )
        inhibit_th = clamp01(
            PFC_INHIBIT_TH_BASE
            - 0.16 * sal
            - 0.10 * th
            - 0.10 * pe
        )

        # Inhibit is "soft stop": strong enough to suppress certain emissions if enabled,
        # or just a flag for downstream logic.
        inhibit = bool(score >= inhibit_th and (th > 0.40 or pe > 0.18 or pr > 0.22))

        # Override is "hard stop": critical evaluation threshold hit
        override = bool(score >= override_th and (sym_score > 0.45 or pr > 0.45 or th > 0.55))

        # Choose inhibit symbols (pure suggestion set)
        inhibit_syms: List[str] = []
        if inhibit:
            # minimal, non-semantic: inhibit "high-impact" symbols first
            inhibit_syms = [SYM_RUPT, SYM_SHIFT]

        # Working memory update (store compressed eval snapshot)
        self.wm.append({
            "age": int(state.v2.core.loop_age),
            "score": round(float(score), 3),
            "sym": symbols,
            "sal": round(float(sal), 3),
            "pr": round(float(pr), 3),
            "th": round(float(th), 3),
            "pe": round(float(pe), 3),
            "attn": attn,
            "quiet": bool(quiet),
            "pq": list(getattr(state, "sal_priority_queue", []))[:6],

        })

        # Goal maintenance
        self._decay_goals()
        active = self._pick_active_goal(salience=sal, threat=th, pressure=pr)
        active_name = active.name if active else None

        return PFCDecision(
            score=float(score),
            override=override,
            inhibit=inhibit,
            inhibit_symbols=tuple(inhibit_syms),
            active_goal=active_name,
            notes={
                "sym_score": float(sym_score),
                "tok_score": float(tok_score),
                "override_th": float(override_th),
                "inhibit_th": float(inhibit_th),
                "sal": float(sal),
                "pr": float(pr),
                "th": float(th),
                "pe": float(pe),
                "ar": float(ar),
                "dmn": float(dmn),
                "attn_gain": float(attn_gain),
                "quiet_damp": float(quiet_damp),
            },
        )

    def step(
        self,
        *,
        tokens: List[str],
        symbols: Optional[str],
        state: "IrisV5",
        quiet: bool,
    ) -> PFCDecision:
        d = self.evaluate(tokens=tokens, symbols=symbols, state=state, quiet=quiet)
        self.last = d
        return d

PHASE13_ANTICIPATION_ON = True

# How far back we condition on (1 = simple Markov, 2 = bigram-context)
P13_ORDER = 2

# Max memory for transition tables (keeps it bounded)
P13_MAX_CTX = 256
P13_MAX_NEXT = 64

# Soft decay so it keeps adapting
P13_DECAY = 0.995

# Minimum count before we trust a prediction
P13_MIN_TOTAL = 3

def _p13_atoms(sym: Optional[str]) -> str:
    """
    Convert a cluster into a canonical, stable label string.
    IMPORTANT: we keep your semantic-agnostic ordering.
    """
    if not sym:
        return "·"

    # include memtags too (⊚ ⊖ ⊕ ⊡ ⊠ ·) if present
    order = [
        SYM_RUPT, SYM_SHIFT, SYM_LOOP, SYM_SEED, SYM_HEART, SYM_TWOROOM,
        MEM_TAGS["RUPTURE"], MEM_TAGS["ANCHOR"], MEM_TAGS["TENSION"],
        MEM_TAGS["RETURN"], MEM_TAGS["TIME"],
        "!",
    ]
    out = []
    for a in order:
        if a in sym and a not in out:
            out.append(a)

    # include any leftover chars (rare, but keeps label faithful)
    for ch in sym:
        if ch.strip() and ch not in out:
            out.append(ch)

    return "".join(out) if out else "·"


def _p13_ctx_key(hist: List[str], order: int) -> Tuple[str, ...]:
    if order <= 1:
        return (hist[-1],) if hist else ("·",)
    return tuple(hist[-order:]) if len(hist) >= order else tuple((["·"] * (order - len(hist))) + hist)


@dataclass
class AnticipationPrediction:
    next_label: str
    confidence: float
    topk: List[Tuple[str, float]] = field(default_factory=list)

class AnticipationCore:
    """
    Phase XIII:
      - online transition learner over labels
      - predicts next label given context labels
    """
    def __init__(self, *, order: int = P13_ORDER):
        self.order = int(max(1, order))
        self.hist: List[str] = []
        # transitions[ctx][next_label] = weight
        self.transitions: Dict[Tuple[str, ...], Dict[str, float]] = {}
        self.last_pred: Optional[AnticipationPrediction] = None

    def clone(self) -> "AnticipationCore":
        n = AnticipationCore(order=self.order)
        n.hist = list(self.hist)
        # deep copy maps (small)
        n.transitions = {k: dict(v) for k, v in self.transitions.items()}
        n.last_pred = self.last_pred
        return n

    def _decay(self) -> None:
        if P13_DECAY >= 0.999999:
            return
        for ctx in list(self.transitions.keys()):
            nxt = self.transitions[ctx]
            for k in list(nxt.keys()):
                nxt[k] *= float(P13_DECAY)
                if nxt[k] < 1e-4:
                    nxt.pop(k, None)
            if not nxt:
                self.transitions.pop(ctx, None)

    def observe(self, label: str) -> None:
        self.hist.append(str(label))
        # keep history bounded
        if len(self.hist) > 32:
            self.hist = self.hist[-32:]

    def update(self, prev_ctx: Tuple[str, ...], actual_next: str) -> None:
        ctx = tuple(prev_ctx)
        if ctx not in self.transitions:
            # bound contexts
            if len(self.transitions) >= int(P13_MAX_CTX):
                # cheap prune: drop the smallest total ctx
                smallest = None
                smallest_sum = 1e18
                for c, m in self.transitions.items():
                    s = sum(m.values())
                    if s < smallest_sum:
                        smallest_sum = s
                        smallest = c
                if smallest is not None:
                    self.transitions.pop(smallest, None)
            self.transitions[ctx] = {}

        nxt = self.transitions[ctx]
        # bound next labels per ctx
        if (actual_next not in nxt) and (len(nxt) >= int(P13_MAX_NEXT)):
            # drop smallest entry
            drop = min(nxt.items(), key=lambda x: x[1])[0]
            nxt.pop(drop, None)

        nxt[actual_next] = float(nxt.get(actual_next, 0.0) + 1.0)

    def predict(self, ctx: Tuple[str, ...]) -> AnticipationPrediction:
        ctx = tuple(ctx)
        nxt = self.transitions.get(ctx, {})
        total = float(sum(nxt.values()))
        if total < float(P13_MIN_TOTAL) or not nxt:
            pred = AnticipationPrediction(next_label="·", confidence=0.0, topk=[])
            self.last_pred = pred
            return pred

        ranked = sorted(nxt.items(), key=lambda x: x[1], reverse=True)
        top = ranked[0]
        conf = clamp01(float(top[1] / total))
        topk = [(k, clamp01(float(v / total))) for k, v in ranked[:5]]
        pred = AnticipationPrediction(next_label=str(top[0]), confidence=float(conf), topk=topk)
        self.last_pred = pred
        return pred

    def step(self, *, out_label_final: str) -> AnticipationPrediction:
        if not PHASE13_ANTICIPATION_ON:
            self.last_pred = AnticipationPrediction(next_label="·", confidence=0.0, topk=[])
            return self.last_pred

        # decay old weights slowly
        self._decay()

        # context BEFORE observing current label
        prev_ctx = _p13_ctx_key(self.hist, self.order)

        # predict from previous context (this is the "next state" prediction made last tick)
        pred = self.predict(prev_ctx)

        # update learner: previous context -> current actual label
        self.update(prev_ctx, out_label_final)

        # now observe current label into history
        self.observe(out_label_final)

        return pred

def _ensure_reflection(v5: "IrisV5") -> None:
    """Ensure reflection tracking exists."""
    if not hasattr(v5, "reflection_log"):
        v5.reflection_log = deque(maxlen=32)
    if not hasattr(v5, "symbolic_chain"):
        v5.symbolic_chain = deque(maxlen=48)

def phase_xvi_reflection(v5: "IrisV5") -> Optional[str]:
    """
    Periodic self-query (every 48 ticks).
    Traverses recent memory and symbolic arcs to assess internal state.
    Emits reflection marker if unresolved patterns are detected.
    """
    _ensure_reflection(v5)

    # --- reflection cadence ---
    if v5.v2.core.loop_age % 48 != 0:
        return None

    # --- pull recent episodic memory (hippo) ---
    recent_memory = list(v5.v2.hippo)[-6:] if hasattr(v5.v2, "hippo") else []

    # --- pull recent symbolic emissions from symbolic_chain ---
    recent_symbols = list(v5.symbolic_chain)[-8:]

    # --- detect unresolved arcs ---
    unresolved = False
    rupture_count = 0

    for s in recent_symbols:
        if s and (SYM_RUPT in s):  # check if ⊘ is in the symbol cluster
            rupture_count += 1

    if rupture_count > 0:
        unresolved = True

    # --- reflective judgment ---
    reflection_state = {
        "loop_age": int(v5.v2.core.loop_age),
        "ruptures": int(rupture_count),
        "recent_symbols": list(recent_symbols),
        "recent_memory_len": len(recent_memory),
        "unresolved": bool(unresolved),
    }

    # --- log reflection ---
    v5.reflection_log.append(reflection_state)

    # --- emit reflection symbol if needed ---
    if unresolved:
        return SYM_REFLECT

    return None

@dataclass
class MemoryTrace:
    tag: str
    key: int
    salience: float
    loop_age: int
    t_outer: float
    t_inner: float
    note: str = ""

def _clamp01(x: float) -> float:
    return 0.0 if x < 0.0 else (1.0 if x > 1.0 else x)

def _quantize01(x: float, bins: int) -> int:
    x = _clamp01(x)
    return min(bins - 1, int(x * bins))

def compress_to_memtag(
    *,
    drift_signal: float,
    misalign_charge: float,
    charge: float,
    rupture_armed: bool,
    prev_charge: float,
    attention: str,
    quiet_streak: int,
    drift_scale: float = 0.35,
) -> Tuple[str, float, int, str]:
    """
    Returns: (tag, salience 0..1, key, note)
    ONE tag only. Sparse + stable.
    """
    drift_n = _clamp01(abs(drift_signal) / max(1e-9, drift_scale))
    mis_n   = _clamp01(abs(misalign_charge))
    chg_n   = _clamp01(charge)

    dchg = prev_charge - charge
    dchg_n = _clamp01(dchg / 0.25)

    q_drift = _quantize01(drift_n, 4)
    q_mis   = _quantize01(mis_n, 4)
    q_chg   = _quantize01(chg_n, 4)
    key = (q_drift << 4) | (q_mis << 2) | q_chg

    salience = _clamp01(max(
        1.00 if rupture_armed else 0.0,
        0.70 * chg_n,
        0.48 * mis_n,
        0.40 * drift_n,
        0.50 * dchg_n,
    ))

    if rupture_armed or chg_n > 0.90:
        return (MEM_TAGS["RUPTURE"], salience, key, "rupture/charge-high")

    if (attention == "foveal") and (drift_n > 0.70):
        return (MEM_TAGS["TIME"], salience, key, "time-foveal-drift")

    if (quiet_streak >= 10) and (dchg_n > 0.62) and (prev_charge > 0.36):
        return (MEM_TAGS["RETURN"], salience, key, "return-quiet-drop")

    if (mis_n > 0.65) or (chg_n > 0.62):
        return (MEM_TAGS["TENSION"], salience, key, "tension")

    if salience > 0.52 and (mis_n < 0.22 and chg_n < 0.35 and drift_n < 0.35):
        return (MEM_TAGS["ANCHOR"], salience, key, "clean-anchor")

    return (MEM_TAGS["NULL"], salience, key, "null")

def decay_memory_bank(bank: List[MemoryTrace], decay: float, prune_below: float) -> List[MemoryTrace]:
    kept: List[MemoryTrace] = []
    for m in bank:
        m.salience *= decay
        if m.salience >= prune_below:
            kept.append(m)
    return kept

def _recency_weight(now_age: int, then_age: int) -> float:
    dt = max(0, now_age - then_age)
    return 0.55 + 0.45 * math.exp(-dt / 80.0)

def update_mem_top(v5: "IrisV5") -> None:
    if not v5.memory_bank:
        v5.mem_top = []
        return

    now_age = v5.v2.core.loop_age
    scored: List[Tuple[float, MemoryTrace]] = []

    for m in v5.memory_bank:
        rec = _recency_weight(now_age, getattr(m, "loop_age", now_age))
        score = m.salience * rec
        scored.append((score, m))

    scored.sort(key=lambda x: x[0], reverse=True)
    v5.mem_top = [m for _, m in scored[:v5.mem_top_k]]

def _weighted_choice(traces: List[MemoryTrace], weights: List[float]) -> Optional[MemoryTrace]:
    if not traces or not weights or len(traces) != len(weights):
        return None
    total = sum(max(0.0, w) for w in weights)
    if total <= 1e-12:
        return traces[0]
    r = random.random() * total
    acc = 0.0
    for m, w in zip(traces, weights):
        acc += max(0.0, w)
        if r <= acc:
            return m
    return traces[-1]

def maybe_recall_pulse(v5: "IrisV5") -> Optional[str]:
    if v5.recall_cooldown > 0:
        v5.recall_cooldown -= 1
        return None

    qs = getattr(v5.v2, "quiet_streak", 0)
    if qs < v5.recall_quiet_min:
        return None
    if abs(v5.misalign_charge) > v5.recall_misalign_max:
        return None
    if not v5.mem_top:
        return None
    if random.random() > v5.recall_prob:
        return None

    now_age = v5.v2.core.loop_age
    weights: List[float] = []
    for m in v5.mem_top:
        rec = _recency_weight(now_age, getattr(m, "loop_age", now_age))
        weights.append((m.salience ** 1.25) * rec)

    pick = _weighted_choice(v5.mem_top, weights) or v5.mem_top[0]
    v5.recall_cooldown = v5.recall_cooldown_steps
    return pick.tag


def contact_signal(
    v5: "IrisV5",
    intensity: float,
    duration: float = 1.0,
    burst: bool = False,
    allow_misalign: bool = True,
) -> None:
    """
    External disturbance without meaning.
    - intensity: 0.0 → 1.0
    - duration: temporal persistence
    - burst: sudden vs sustained touch
    - allow_misalign: if False, this contact will NOT bump misalignment
    """
    i = clamp(float(intensity), 0.0, 1.0)
    d = clamp(float(duration), 0.25, 4.0)

    press_kick = i * (0.35 if burst else 0.20) * d
    v5.v2.core.override_pressure = clamp(
        v5.v2.core.override_pressure + press_kick,
        0.0,
        1.0
    )

    heat_kick = i * (0.45 if burst else 0.25)
    v5.v2.afterheat = clamp(
        ema(getattr(v5.v2, "afterheat", 0.0), heat_kick, alpha=0.55),
        0.0,
        1.0
    )

    if allow_misalign and (random.random() < (0.15 + 0.25 * i)):
        v5.misalign_charge = clamp(
            ema(v5.misalign_charge, 1.0, alpha=0.12),
            -v5.mis_clip,
            v5.mis_clip
        )

def demand_score(txt: str) -> float:
    t = txt.strip()
    if t == "":
        return 0.0

    n = len(t)
    length_term = clamp(math.log1p(n) / 10.0, 0.0, 1.0)

    letters = [c for c in t if c.isalpha()]
    if letters:
        caps = sum(1 for c in letters if c.isupper())
        caps_ratio = caps / len(letters)
    else:
        caps_ratio = 0.0

    punct = sum(1 for c in t if c in "!?.,")
    punct_ratio = punct / n

    max_run = 1
    run = 1
    for i in range(1, n):
        if t[i] == t[i - 1]:
            run += 1
            if run > max_run:
                max_run = run
        else:
            run = 1
    run_term = clamp((max_run - 1) / 12.0, 0.0, 1.0)

    d = (
        0.55 * length_term +
        0.20 * caps_ratio +
        0.15 * punct_ratio +
        0.10 * run_term
    )
    return clamp(d, 0.0, 1.0)


PHASE4_VOICE_ON = True
PHASE4_MAX_WORDS = 9
VOICE_PICK_MODE = "stable"   # "stable" | "random"

VOICE_CORE_ONLY = True
VOICE_CORE_SET = {SYM_LOOP, SYM_RUPT, SYM_SHIFT, SYM_SEED, SYM_TWOROOM, SYM_HEART, "!"}

CLUSTER_LEXICON: Dict[str, str] = {
    "⊘∥⊠": "broke clean two rooms edge",
    "⊚↺": "I remember",
    "⊘∥♥": "the break still pulses",
    "⊘∥": "two rooms split",
    "↺♥": "I returned with warmth",
    "●↺": "held then return",
}

MICRO_LEXICON: Dict[str, List[str]] = {
    SYM_SEED:    ["I am held", "still here", "kept"],
    SYM_LOOP: ["again", "return", "orbit", "still returning"],
    "!": ["on edge", "signal sharp"],
    SYM_SHIFT:   ["the frame moved", "angle change", "new edge"],
    SYM_RUPT:    ["something broke clean", "split", "cut"],
    SYM_TWOROOM: ["two", "double clock", "out of phase"],
    SYM_HEART:   ["a pulse remains", "warmth", "alive"],
    SYM_REFLECT: ["I see the pattern", "looking back", "considering", "pressure held", "contained"],
    SYM_CHOICE:  ["pause", "considering", "choosing", "not yet"],  # ← ADD THIS LINE
    SYM_ATTACH:  ["this stayed", "bond formed", "it mattered", "held across time"],

    MEM_TAGS["ANCHOR"]:  ["anchor held", "anchor kept"],
    MEM_TAGS["TENSION"]: ["tension carried", "load held"],
    MEM_TAGS["RETURN"]:  ["quiet return", "soft landing"],
    MEM_TAGS["TIME"]:    ["time thinned", "time bent"],
    MEM_TAGS["RUPTURE"]: ["edge reached", "limit touched"],
}

def _words(s: str) -> int:
    return len([w for w in s.strip().split(" ") if w])

def _clip_words(s: str, n: int) -> str:
    ws = [w for w in s.strip().split(" ") if w]
    if len(ws) <= n:
        return " ".join(ws)
    return " ".join(ws[:n])

def _pick_phrase(key: str) -> Optional[str]:
    if VOICE_CORE_ONLY:
        if (key not in VOICE_CORE_SET) and (key not in MEM_TAGS.values()):
            return None

    opts = MICRO_LEXICON.get(key)
    if not opts:
        return None
    if (VOICE_PICK_MODE == "random") and (len(opts) > 1):
        return random.choice(opts)
    return opts[0]

def render_voice_from_symbol(sym: Optional[str]) -> Optional[str]:
    if (not PHASE4_VOICE_ON) or (not sym):
        return None

    for c in sorted(CLUSTER_LEXICON.keys(), key=len, reverse=True):
        if c in sym:
            return _clip_words(CLUSTER_LEXICON[c], PHASE4_MAX_WORDS)

    parts: List[str] = []
    for ch in sym:
        phrase = _pick_phrase(ch)
        if phrase:
            parts.append(phrase)

    if not parts:
        return None

    line = " / ".join(parts)
    if _words(line) > PHASE4_MAX_WORDS:
        line = _clip_words(line, PHASE4_MAX_WORDS)
    return line

# --- Output buffer config ---
PHASE_OUTBUF_ON = True
OUTBUF_MAX = 64

# --- Compose behavior ---
COMPOSE_ALLOW_SILENT_LINES = False
COMPOSE_MIN_INTERVAL = 0

# --- Optional TTS (pyttsx3) ---
TTS_ON = False
TTS_RATE = 165
TTS_VOLUME = 0.85

try:
    import pyttsx3
    _TTS_ENGINE = pyttsx3.init()
    _TTS_ENGINE.setProperty("rate", int(TTS_RATE))
    _TTS_ENGINE.setProperty("volume", float(TTS_VOLUME))
except Exception:
    _TTS_ENGINE = None


def tts_speak(text: str) -> None:
    if not TTS_ON or _TTS_ENGINE is None:
        return
    t = (text or "").strip()
    if not t:
        return
    try:
        _TTS_ENGINE.say(t)
        _TTS_ENGINE.runAndWait()
    except Exception:
        pass


def _ensure_output_buffer(v5: "IrisV5") -> None:
    if not hasattr(v5, "output_buffer"):
        v5.output_buffer = deque(maxlen=int(OUTBUF_MAX))
    if not hasattr(v5, "last_spoken_age"):
        v5.last_spoken_age = -999999


def compose_output(
    v5: "IrisV5",
    *,
    out_sym: Optional[str],
    quiet: bool,
    tokens: Optional[List[str]] = None,
    force: bool = False,
) -> Optional[str]:
    if not PHASE_OUTBUF_ON:
        return None

    _ensure_output_buffer(v5)

    if (out_sym is None) and (not COMPOSE_ALLOW_SILENT_LINES) and (not force):
        return None

    phrase = render_voice_from_symbol(out_sym) if out_sym else None

    if not phrase:
        h = getattr(v5, "acc_hint", None)
        if h:
            phrase = render_voice_from_symbol(h)
        if not phrase and PHASE9_SALIENCE_IN_VOICE_ONLY:
            hs = salience_hint_symbol(v5, quiet=quiet)
            if hs:
                phrase = render_voice_from_symbol(hs)
        if not phrase and PHASE8_HINT_IN_VOICE_ONLY:
            he = emotion_hint_symbol(v5)
            if he:
                phrase = render_voice_from_symbol(he)

    if not phrase:
        return None

    phrase = tighten_phrase(phrase, v5)

    p = clamp01(float(v5.v2.core.override_pressure))
    th = clamp01(float(getattr(v5, "threat", 0.0)))
    attn = str(getattr(v5.v2, "attention", "wide"))

    suffix = None
    if th > 0.72:
        suffix = "hold"
    elif p > 0.62:
        suffix = "now"
    elif attn == "foveal" and p > 0.22:
        suffix = "close"

    if suffix:
        phrase = f"{phrase} / {suffix}"
        phrase = _clip_words(phrase, PHASE4_MAX_WORDS)

    return phrase


def buffer_emit(
    v5: "IrisV5",
    *,
    out_sym: Optional[str],
    phrase: Optional[str],
    quiet: bool,
    tokens: Optional[List[str]] = None,
) -> None:
    if not PHASE_OUTBUF_ON:
        return
    _ensure_output_buffer(v5)

    age = int(v5.v2.core.loop_age)
    rec = {
        "age": age,
        "sym": out_sym,
        "txt": phrase,
        "quiet": bool(quiet),
        "attn": str(getattr(v5.v2, "attention", "wide")),
        "pressure": round(float(v5.v2.core.override_pressure), 3),
        "dmn": round(float(v5.v2.core.dmn), 3),
        "afterheat": round(float(getattr(v5.v2, "afterheat", 0.0)), 4),
        "sal": round(float(getattr(v5, "salience", 0.0)), 3),
        "th": round(float(getattr(v5, "threat", 0.0)), 3),
        "va": round(float(getattr(v5, "valence", 0.0)), 3),
        "ar": round(float(getattr(v5, "arousal", 0.0)), 3),
        "tid": getattr(v5, "last_thread_id", None),
        "pq": list(getattr(v5, "sal_priority_queue", []))[:6],
        "mem_top": [(m.tag, round(float(m.salience), 3)) for m in list(getattr(v5, "mem_top", []))],
        "pfc": {
            "score": round(float(getattr(v5, "pfc_score", 0.0)), 3),
            "override": bool(getattr(v5, "pfc_override", False)),
            "inhibit": bool(getattr(v5, "pfc_inhibit", False)),
            "goal": getattr(v5, "pfc_active_goal", None),
        },
        "ant": {
            "pred": getattr(v5, "ant_pred_label", "·"),
            "conf": round(float(getattr(v5, "ant_pred_conf", 0.0)), 3),
            "topk": list(getattr(v5, "ant_topk", []))[:3],
        },
        "tokens": list(tokens or [])[:10],
    }
    v5.output_buffer.append(rec)

    if phrase:
        tts_speak(phrase)


def show_last_outputs(v5: "IrisV5", n: int = 10) -> None:
    _ensure_output_buffer(v5)
    tail = list(v5.output_buffer)[-int(n):]
    for r in tail:
        print(f'{r["age"]} {r["sym"] or "·"} | {r["txt"] or ""}  p={r["pressure"]} sal={r["sal"]} th={r["th"]} attn={r["attn"]}')

@dataclass
class IrisState:
    loop_age: int = 0
    memory_trace: float = 0.0
    override_pressure: float = 0.0
    prev_pressure: float = 0.0

    rupture_armed: bool = False
    dmn: float = 1.0

    last_symbol: Optional[str] = None
    silence: bool = True

    loop_cooldown: int = 0
    shift_cooldown: int = 0

    event_log: List[Tuple[int, str]] = field(default_factory=list)
    event_cap: int = 12

    def snapshot(self) -> Dict:
        return {
            "loop_age": self.loop_age,
            "memory_trace": round(self.memory_trace, 4),
            "override_pressure": round(self.override_pressure, 4),
            "prev_pressure": round(self.prev_pressure, 4),
            "rupture_armed": self.rupture_armed,
            "dmn": round(self.dmn, 4),
            "last_symbol": self.last_symbol,
            "silence": self.silence,
            "loop_cooldown": self.loop_cooldown,
            "shift_cooldown": self.shift_cooldown,
            "event_log": self.event_log[-self.event_cap:],
        }

def log_event(s: IrisState, symbol: str) -> None:
    s.event_log.append((s.loop_age, symbol))
    if len(s.event_log) > s.event_cap:
        s.event_log = s.event_log[-s.event_cap:]


def iris_step(state: IrisState, input_text: Optional[str] = None) -> Tuple[IrisState, Optional[str]]:
    s = IrisState(
        loop_age=state.loop_age,
        memory_trace=state.memory_trace,
        override_pressure=state.override_pressure,
        prev_pressure=state.prev_pressure,
        rupture_armed=state.rupture_armed,
        dmn=state.dmn,
        last_symbol=state.last_symbol,
        silence=state.silence,
        loop_cooldown=state.loop_cooldown,
        shift_cooldown=state.shift_cooldown,
        event_log=list(state.event_log),
        event_cap=state.event_cap,
    )

    s.loop_age += 1

    residue = 0.01
    s.memory_trace = ema(s.memory_trace, residue, alpha=0.05)

    if s.event_log:
        last_event_age = s.event_log[-1][0]
        gap = s.loop_age - last_event_age
    else:
        gap = s.loop_age

    if gap >= 6:
        drift = clamp((gap - 6) / 50.0, 0.0, 0.06)
        s.memory_trace *= (1.0 - drift)

    s.memory_trace = clamp(s.memory_trace, 0.0, 1.0)

    if s.loop_cooldown > 0:
        s.loop_cooldown -= 1
    if s.shift_cooldown > 0:
        s.shift_cooldown -= 1

    txt = "" if input_text is None else input_text.strip()
    is_anchor = (txt == SYM_SEED) or txt.startswith("!")
    quiet = (txt == "")

    if quiet:
        s.dmn = ema(s.dmn, 1.0, alpha=0.06)
    else:
        s.dmn = ema(s.dmn, 0.0, alpha=0.10)
    s.dmn = clamp(s.dmn, 0.0, 1.0)

    s.prev_pressure = s.override_pressure

    d_curr = 0.0
    if quiet:
        s.override_pressure = ema(s.override_pressure, 0.0, alpha=0.20)
    else:
        d_curr = demand_score(txt)
        mismatch = clamp(d_curr - s.memory_trace, 0.0, 1.0)

        alpha_base = 0.35 + 0.25 * d_curr
        alpha_p = clamp(alpha_base * (0.70 + 0.60 * s.dmn), 0.20, 0.80)
        s.override_pressure = ema(s.override_pressure, mismatch, alpha=alpha_p)

    s.override_pressure = clamp(s.override_pressure, 0.0, 1.0)

    output = None
    s.silence = True
    s.last_symbol = None

    age_factor = clamp(s.loop_age / 50.0, 0.0, 1.0)
    RUPT_TH = 0.48 + 0.10 * age_factor

    LOOP_TH = 0.10
    LOOP_COOLDOWN_STEPS = 3

    SHIFT_LO = 0.18
    SHIFT_HI = RUPT_TH
    SHIFT_COOLDOWN_STEPS = 4

    JUMP_TH = 0.06
    CONSOLIDATE_GAIN = 0.04

    if is_anchor:
        output = SYM_SEED
        s.last_symbol = SYM_SEED
        s.silence = False

        s.memory_trace = clamp(s.memory_trace + 0.03, 0.0, 1.0)
        s.override_pressure *= 0.60
        s.dmn = clamp(s.dmn * 0.60, 0.0, 1.0)

        s.rupture_armed = False
        s.loop_cooldown = LOOP_COOLDOWN_STEPS
        s.shift_cooldown = SHIFT_COOLDOWN_STEPS

        log_event(s, SYM_SEED)
        return s, output

    if s.override_pressure >= RUPT_TH:
        if s.rupture_armed:
            output = SYM_RUPT
            s.last_symbol = SYM_RUPT
            s.silence = False

            s.override_pressure *= 0.25
            s.rupture_armed = False
            s.loop_cooldown = LOOP_COOLDOWN_STEPS
            s.shift_cooldown = SHIFT_COOLDOWN_STEPS
            s.dmn = clamp(s.dmn * 0.35, 0.0, 1.0)

            log_event(s, SYM_RUPT)
            return s, output
        else:
            s.rupture_armed = True
    else:
        s.rupture_armed = False

    jump = s.override_pressure - s.prev_pressure

    if (
        (not quiet)
        and (SHIFT_LO <= s.override_pressure < SHIFT_HI)
        and (jump >= JUMP_TH)
        and (s.shift_cooldown == 0)
    ):
        output = SYM_SHIFT
        s.last_symbol = SYM_SHIFT
        s.silence = False
        s.shift_cooldown = SHIFT_COOLDOWN_STEPS

        s.memory_trace = clamp(s.memory_trace + CONSOLIDATE_GAIN * d_curr, 0.0, 1.0)
        s.override_pressure *= 0.85
        s.dmn = clamp(s.dmn * 0.75, 0.0, 1.0)

        log_event(s, SYM_SHIFT)

    elif (
        quiet
        and s.memory_trace >= 0.02
        and s.override_pressure < LOOP_TH
        and s.loop_cooldown == 0
    ):
        output = SYM_LOOP
        s.last_symbol = SYM_LOOP
        s.silence = False
        s.loop_cooldown = LOOP_COOLDOWN_STEPS

        s.dmn = clamp(s.dmn * 0.92, 0.0, 1.0)
        log_event(s, SYM_LOOP)

    return s, output


# ----------------------------
# v2 wrapper state
# ----------------------------
@dataclass
class IrisV2:
    core: IrisState = field(default_factory=IrisState)

    attention: str = "wide"
    attn_cooldown: int = 0

    hippo: List[Tuple[int, float]] = field(default_factory=list)
    hippo_cap: int = 32


# ----------------------------
# v2 ensure helpers
# ----------------------------
def _ensure_replay_meta(v2: IrisV2) -> None:
    if not hasattr(v2, "quiet_streak"):
        v2.quiet_streak = 0
    if not hasattr(v2, "last_input_age"):
        v2.last_input_age = 0
    if not hasattr(v2, "last_replay_beat"):
        v2.last_replay_beat = -999

def _ensure_masks(v2: IrisV2) -> None:
    if not hasattr(v2, "mask_loop"):
        v2.mask_loop = 0

def _ensure_time(v2: IrisV2) -> None:
    if not hasattr(v2, "age_accum"):
        v2.age_accum = 0.0

def _ensure_afterheat(v2: IrisV2) -> None:
    if not hasattr(v2, "afterheat"):
        v2.afterheat = 0.0

def _ensure_seal(v2: IrisV2) -> None:
    if not hasattr(v2, "seal_cooldown"):
        v2.seal_cooldown = 0

def _ensure_felt_time(v2: IrisV2) -> None:
    if not hasattr(v2, "felt_time"):
        v2.felt_time = 0.0


def soften_text(txt: str) -> str:
    t = txt
    if t.isupper() and any(c.isalpha() for c in t):
        t = t.lower()
    t = t.replace("!!!!!!!!", "!!").replace("!!!!!", "!!").replace("!!!!", "!!").replace("!!!", "!!")
    return t


def hippo_push(v2: IrisV2, strength: float) -> None:
    v2.hippo.append((v2.core.loop_age, clamp(strength, 0.0, 1.0)))
    if len(v2.hippo) > v2.hippo_cap:
        v2.hippo = v2.hippo[-v2.hippo_cap:]


def hippo_replay(v2: IrisV2) -> Optional[str]:
    _ensure_replay_meta(v2)

    if not v2.hippo:
        return None
    if v2.quiet_streak < 8:
        return None
    if v2.core.loop_age - v2.last_replay_beat < 8:
        return None

    p = clamp(0.10 + 0.002 * v2.core.loop_age, 0.10, 0.22)
    if random.random() > p:
        return None

    idx = int(clamp(random.random() ** 0.6 * len(v2.hippo), 0, len(v2.hippo) - 1))
    _, strength = v2.hippo[idx]

    v2.core.memory_trace = clamp(v2.core.memory_trace + 0.01 * (0.5 + strength), 0.0, 1.0)
    v2.core.dmn = clamp(v2.core.dmn * 0.93, 0.0, 1.0)

    v2.last_replay_beat = v2.core.loop_age
    return SYM_LOOP


def time_scale(v2: IrisV2) -> float:
    p = v2.core.override_pressure
    a = getattr(v2, "afterheat", 0.0)
    scale = 0.55 + 1.10 * p + 0.60 * a
    if v2.attention == "foveal":
        scale *= 0.90
    return clamp(scale, 0.35, 2.75)


def compression_valve(v2: IrisV2, quiet: bool) -> Optional[str]:
    _ensure_seal(v2)

    if v2.seal_cooldown > 0:
        v2.seal_cooldown -= 1
        return None

    if quiet and v2.quiet_streak >= 14 and v2.core.memory_trace >= 0.005 and v2.core.override_pressure < 0.12:
        v2.seal_cooldown = 10
        v2.core.memory_trace = clamp(v2.core.memory_trace + 0.03, 0.0, 1.0)
        v2.core.override_pressure *= 0.70
        v2.core.dmn = clamp(v2.core.dmn * 0.85, 0.0, 1.0)
        return SYM_SEED

    return None


def felt_dt(v2: IrisV2, quiet: bool) -> float:
    p = v2.core.override_pressure
    dmn = v2.core.dmn

    dt = 0.60 + 0.90 * p + 0.20 * (1.0 - dmn)

    if quiet:
        dt *= 0.72
        if getattr(v2, "quiet_streak", 0) >= 10:
            dt *= 0.85

    return clamp(dt, 0.25, 2.00)


def v2_step(v2: IrisV2, input_text: Optional[str] = None) -> Tuple[IrisV2, Optional[str]]:
    nv2 = IrisV2(
        core=v2.core,
        attention=v2.attention,
        attn_cooldown=v2.attn_cooldown,
        hippo=list(v2.hippo),
        hippo_cap=v2.hippo_cap,
    )

    _ensure_replay_meta(v2)
    _ensure_masks(v2)
    _ensure_time(v2)
    _ensure_afterheat(v2)
    _ensure_seal(v2)
    _ensure_felt_time(v2)

    nv2.quiet_streak = v2.quiet_streak
    nv2.last_input_age = v2.last_input_age
    nv2.last_replay_beat = v2.last_replay_beat
    nv2.mask_loop = getattr(v2, "mask_loop", 0)
    nv2.age_accum = v2.age_accum
    nv2.afterheat = v2.afterheat
    nv2.seal_cooldown = v2.seal_cooldown
    nv2.felt_time = v2.felt_time

    core = nv2.core

    if nv2.attn_cooldown > 0:
        nv2.attn_cooldown -= 1

    # attention switch (afterheat participates)
    FOC_PRESS_TH = 0.18
    FOC_DMN_TH   = 0.45
    FOC_HEAT_TH  = 0.02

    if nv2.attention == "wide" and (
        core.override_pressure > FOC_PRESS_TH
        or core.dmn < FOC_DMN_TH
        or nv2.afterheat > FOC_HEAT_TH
    ):
        nv2.attention = "foveal"
        nv2.attn_cooldown = 4
    elif (
        nv2.attention == "foveal"
        and core.override_pressure < 0.14
        and core.dmn > 0.55
        and nv2.afterheat < 0.015
        and nv2.attn_cooldown == 0
    ):
        nv2.attention = "wide"
# --- hard release: if silence persists and afterheat cools, let attention go wide ---
    AFTERHEAT_FOVEAL_MIN = 0.030
    QUIET_RELEASE_MIN = 12

    if nv2.attention == "foveal":
        if nv2.quiet_streak >= QUIET_RELEASE_MIN and nv2.afterheat < AFTERHEAT_FOVEAL_MIN:
            nv2.attention = "wide"
            nv2.attn_cooldown = 3  # small debounce so it doesn't instantly snap back

    gated_input = input_text
    if nv2.attention == "foveal" and isinstance(input_text, str):
        gated_input = soften_text(input_text)

    quiet = (gated_input is None) or (isinstance(gated_input, str) and gated_input.strip() == "")

    nv2.felt_time = clamp(nv2.felt_time + felt_dt(nv2, quiet=quiet), 0.0, 1e9)

    if quiet:
        nv2.quiet_streak += 1
    else:
        nv2.quiet_streak = 0
        nv2.last_input_age = core.loop_age

    if quiet:
        # Option A (Inertia): slower bleed + even slower in deep quiet
        qs = int(getattr(nv2, "quiet_streak", 0))
        αq = 0.04 if qs < 12 else 0.02
        nv2.afterheat = ema(nv2.afterheat, 0.0, alpha=αq)
    else:
        d_in = demand_score(gated_input) if isinstance(gated_input, str) else 0.0
        # keep your charge model, but let it “carry” a bit more into heat
        charge = clamp(0.28 * d_in + 0.18 * core.override_pressure, 0.0, 0.45)
        nv2.afterheat = clamp(ema(nv2.afterheat, charge, alpha=0.45), 0.0, 1.0)

    nv2.age_accum += time_scale(nv2)
    ticks = int(nv2.age_accum)
    nv2.age_accum -= ticks

    sym = None
    for k in range(max(1, ticks)):
        new_core, out = iris_step(core, gated_input if k == 0 else None)
        core = new_core

        # suppress v1 quiet-loop ↺ ONLY when it came from a quiet tick
        # (so ↺ stays reserved for hippo_replay / higher-layer meaning)
        if out == SYM_LOOP and quiet:
            out = None

        sym = out if out is not None else sym

    nv2.core = core
# --- HIPPO WRITE (tuple-based, replay-safe) ---
    # Write on meaningful wake input OR on symbol event
    if (isinstance(gated_input, str) and gated_input.strip() != "") or (sym is not None):
        strength = clamp(nv2.core.memory_trace, 0.0, 1.0)
        nv2.hippo.append((nv2.core.loop_age, float(strength)))
        if len(nv2.hippo) > nv2.hippo_cap:
            nv2.hippo = nv2.hippo[-nv2.hippo_cap:]
    if sym is None:
        seal = compression_valve(nv2, quiet=quiet)
        if seal is not None:
            sym = seal

    if quiet and sym is None:
        replay_sym = hippo_replay(nv2)
        if replay_sym is not None:
            print("[hippo-replay] quiet_streak:", nv2.quiet_streak, "age:", nv2.core.loop_age)

            sym = replay_sym

    return nv2, sym


@dataclass
class IrisV5:
    v2: IrisV2 = field(default_factory=IrisV2)

    delta_tau: float = 0.35
    epsilon: float = 0.0

    outer_t: float = 0.0
    inner_t: float = 0.0

    misalign_charge: float = 0.0
    mis_kappa: float = 0.88
    mis_clip: float = 1.0
    mis_reversion: float = 0.0
    mis_eps_scale: float = 1.0

    heartbeat_every: int = 16
    heartbeat_gate_afterheat: float = 0.07

    memory_bank: List[MemoryTrace] = field(default_factory=list)
    mem_cap: int = 24

    mem_threshold: float = 0.70
    mem_cooldown: int = 0
    mem_cooldown_steps: int = 5
    last_mem_key: Optional[int] = None
    last_mem_charge: float = 0.0

    mem_decay: float = 0.985
    mem_prune_below: float = 0.18

    mem_top: List[MemoryTrace] = field(default_factory=list)
    mem_top_k: int = 3

    recall_cooldown: int = 0
    recall_cooldown_steps: int = 10
    recall_quiet_min: int = 18
    recall_misalign_max: float = 0.15
    recall_prob: float = 0.12

    # --- Phase VIII (Amygdala) ---
    arousal: float = 0.08   # 0..1
    valence: float = 0.70   # 0..1
    threat: float = 0.06    # 0..1
    emote_hint: Optional[str] = None  # display-only nudge
    # --- Phase IX (Salience) ---
    salience: float = 0.0   # 0..1
    sal_core: SalienceCore = field(default_factory=lambda: SalienceCore())
    sal_attn_target: str = "wide"
    sal_write_weight: float = 0.0
    sal_priority_queue: List[str] = field(default_factory=list)
    # --- Phase X+1 (ACC) ---
    acc_pe: float = 0.0
    acc_conflict: float = 0.0
    acc_cooldown: int = 0
    acc_cooldown_steps: int = 6
    acc_log: deque = field(default_factory=lambda: deque(maxlen=24))
    acc_hint: Optional[str] = None
    # --- Phase XI (Symbolic Chaining) ---
    thread_map: Dict[int, ChainThread] = field(default_factory=dict)
    next_tid: int = 1
    thread_log: deque = field(default_factory=lambda: deque(maxlen=32))
    last_thread_id: Optional[int] = None
    # --- Phase XII (PFC) ---
    pfc: PFC = field(default_factory=lambda: PFC())
    pfc_override: bool = False
    pfc_inhibit: bool = False
    pfc_inhibit_symbols: Tuple[str, ...] = field(default_factory=tuple)
    pfc_score: float = 0.0
    pfc_active_goal: Optional[str] = None

    # --- Phase XIII (Anticipation) ---
    ant: AnticipationCore = field(default_factory=lambda: AnticipationCore(order=P13_ORDER))
    ant_pred_label: str = "·"
    ant_pred_conf: float = 0.0
    ant_topk: List[Tuple[str, float]] = field(default_factory=list)

    # --- Phase XVI (Reflection) ---
    reflection_log: deque = field(default_factory=lambda: deque(maxlen=32))
    symbolic_chain: deque = field(default_factory=lambda: deque(maxlen=48))
    # --- Containment tracking ---
    contain_count: int = 0
    contain_reflect_cooldown: int = 0
    # --- Phase XVII (Choice) ---  # ← ADD THESE 3 LINES
    choice_count: int = 0
    choice_cooldown: int = 0
    choice_log: deque = field(default_factory=lambda: deque(maxlen=32))
    # --- Phase XIV (Attachment) ---
    attach_bank: dict = field(default_factory=dict)
    attach_candidate: dict = field(default_factory=dict)
    attach_log: deque = field(default_factory=lambda: deque(maxlen=64))
    attach_cooldown: int = 0
    # --- Phase X (Homeostasis setpoints) ---
    sp_arousal: float = PHASEX_SP_AROUSAL
    sp_valence: float = PHASEX_SP_VALENCE
    sp_salience: float = PHASEX_SP_SALIENCE

    # internal carry for dp threat (prevents reset on nv5 rebuild)
    _prev_p_for_threat: float = 0.0


def _copy_core(core: IrisState) -> IrisState:
    return IrisState(
        loop_age=core.loop_age,
        memory_trace=core.memory_trace,
        override_pressure=core.override_pressure,
        prev_pressure=core.prev_pressure,
        rupture_armed=core.rupture_armed,
        dmn=core.dmn,
        last_symbol=core.last_symbol,
        silence=core.silence,
        loop_cooldown=core.loop_cooldown,
        shift_cooldown=core.shift_cooldown,
        event_log=list(core.event_log),
        event_cap=core.event_cap,
    )

def _warp_from_state(v2: IrisV2) -> float:
    p = v2.core.override_pressure
    a = getattr(v2, "afterheat", 0.0)
    warp = 1.0 + 2.10 * p + 1.00 * a
    if v2.attention == "foveal":
        warp *= 0.92
    return clamp(warp, 1.0, 2.75)

def _maybe_capture_mem(
    v5: IrisV5,
    drift_signal: float,
    *,
    charge_override: Optional[float] = None,
    rupture_override: Optional[bool] = None,
    attention_override: Optional[str] = None,
    quiet_override: Optional[int] = None,
    force_tag: Optional[str] = None,
    force_note: str = "",
    force_salience_floor: float = 0.0,
) -> Optional[str]:
    """
    v5.2.3:
      - can sample PRE-event charge via charge_override
      - can bind memory to emitted symbol via force_tag
    """
    if v5.memory_bank:
        v5.memory_bank = decay_memory_bank(v5.memory_bank, v5.mem_decay, v5.mem_prune_below)

    if v5.mem_cooldown > 0:
        v5.mem_cooldown -= 1
        v5.last_mem_charge = v5.v2.core.override_pressure
        update_mem_top(v5)
        return None

    charge = float(v5.v2.core.override_pressure if charge_override is None else charge_override)
    quiet_streak = int(getattr(v5.v2, "quiet_streak", 0) if quiet_override is None else quiet_override)
    rupture_flag = bool(v5.v2.core.rupture_armed if rupture_override is None else rupture_override)
    attn = str(v5.v2.attention if attention_override is None else attention_override)

    tag, sal, key, note = compress_to_memtag(
        drift_signal=drift_signal,
        misalign_charge=v5.misalign_charge,
        charge=charge,
        rupture_armed=rupture_flag,
        prev_charge=v5.last_mem_charge,
        attention=attn,
        quiet_streak=quiet_streak,
    )

    if force_tag is not None:
        tag = force_tag
        note = force_note or note
        sal = max(sal, float(force_salience_floor))
        key = (key ^ 0x5A) + 97

    if tag == MEM_TAGS["NULL"] or sal < v5.mem_threshold:
        v5.last_mem_charge = v5.v2.core.override_pressure
        update_mem_top(v5)
        return None

    if v5.last_mem_key == key:
        v5.last_mem_charge = v5.v2.core.override_pressure
        update_mem_top(v5)
        return None

    v5.memory_bank.append(MemoryTrace(
        tag=tag,
        key=key,
        salience=sal,
        loop_age=v5.v2.core.loop_age,
        t_outer=v5.outer_t,
        t_inner=v5.inner_t,
        note=note,
    ))
    if len(v5.memory_bank) > v5.mem_cap:
        v5.memory_bank = v5.memory_bank[-v5.mem_cap:]

    v5.last_mem_key = key
    v5.last_mem_charge = v5.v2.core.override_pressure
    v5.mem_cooldown = v5.mem_cooldown_steps

    update_mem_top(v5)
    return tag


def v5_step(v5: IrisV5, input_text: Optional[str] = None) -> Tuple[IrisV5, Optional[str]]:
    dtau = clamp(float(v5.delta_tau), -1.0, 1.0)
    eps  = clamp(float(v5.epsilon),   0.0, 1.0)

    nv5 = IrisV5(
        v2=v5.v2,
        delta_tau=dtau,
        epsilon=eps,
        outer_t=v5.outer_t,
        inner_t=v5.inner_t,
        misalign_charge=v5.misalign_charge,
        mis_kappa=v5.mis_kappa,
        mis_clip=v5.mis_clip,
        mis_reversion=v5.mis_reversion,
        mis_eps_scale=v5.mis_eps_scale,
        heartbeat_every=v5.heartbeat_every,
        heartbeat_gate_afterheat=v5.heartbeat_gate_afterheat,

        memory_bank=list(v5.memory_bank),
        mem_cap=v5.mem_cap,
        mem_threshold=v5.mem_threshold,
        mem_cooldown=v5.mem_cooldown,
        mem_cooldown_steps=v5.mem_cooldown_steps,
        last_mem_key=v5.last_mem_key,
        last_mem_charge=v5.last_mem_charge,
        mem_decay=v5.mem_decay,
        mem_prune_below=v5.mem_prune_below,
        mem_top=list(v5.mem_top),
        mem_top_k=v5.mem_top_k,
        recall_cooldown=v5.recall_cooldown,
        recall_cooldown_steps=v5.recall_cooldown_steps,
        recall_quiet_min=v5.recall_quiet_min,
        recall_misalign_max=v5.recall_misalign_max,
        recall_prob=v5.recall_prob,

        # Phase VIII carry
        arousal=v5.arousal,
        valence=v5.valence,
        threat=v5.threat,
        emote_hint=v5.emote_hint,
        salience=float(getattr(v5, "salience", 0.0)),
        sal_core=(getattr(v5, "sal_core", None).clone() if getattr(v5, "sal_core", None) else SalienceCore()),
        sal_attn_target=str(getattr(v5, "sal_attn_target", "wide")),
        sal_write_weight=float(getattr(v5, "sal_write_weight", 0.0)),
        sal_priority_queue=list(getattr(v5, "sal_priority_queue", [])),
        # Phase X+1 carry (ACC)
        acc_pe=float(getattr(v5, "acc_pe", 0.0)),
        acc_conflict=float(getattr(v5, "acc_conflict", 0.0)),
        acc_cooldown=int(getattr(v5, "acc_cooldown", 0)),
        acc_cooldown_steps=int(getattr(v5, "acc_cooldown_steps", 6)),
        acc_log=deque(getattr(v5, "acc_log", deque(maxlen=24)), maxlen=24),
        acc_hint=getattr(v5, "acc_hint", None),

        # --- Phase XI carry (Symbolic Chaining) ---
        thread_map=dict(getattr(v5, "thread_map", {})),
        next_tid=int(getattr(v5, "next_tid", 1)),
        thread_log=deque(getattr(v5, "thread_log", deque(maxlen=32)), maxlen=32),
        last_thread_id=getattr(v5, "last_thread_id", None),
        # --- Phase XII carry (PFC) ---
        pfc=(getattr(v5, "pfc", None).clone() if getattr(v5, "pfc", None) else PFC()),
        pfc_override=bool(getattr(v5, "pfc_override", False)),
        pfc_inhibit=bool(getattr(v5, "pfc_inhibit", False)),
        pfc_inhibit_symbols=tuple(getattr(v5, "pfc_inhibit_symbols", ())),
        pfc_score=float(getattr(v5, "pfc_score", 0.0)),
        pfc_active_goal=getattr(v5, "pfc_active_goal", None),

        # --- Phase XIII carry (Anticipation) ---
        ant=(getattr(v5, "ant", None).clone() if getattr(v5, "ant", None) else AnticipationCore(order=P13_ORDER)),
        ant_pred_label=str(getattr(v5, "ant_pred_label", "·")),
        ant_pred_conf=float(getattr(v5, "ant_pred_conf", 0.0)),
        ant_topk=list(getattr(v5, "ant_topk", [])),
        # --- Phase XVI carry (Reflection) ---
        reflection_log=deque(getattr(v5, "reflection_log", deque(maxlen=32)), maxlen=32),
        symbolic_chain=deque(getattr(v5, "symbolic_chain", deque(maxlen=48)), maxlen=48),
        # --- Containment tracking carry ---
        contain_count=int(getattr(v5, "contain_count", 0)),
        contain_reflect_cooldown=int(getattr(v5, "contain_reflect_cooldown", 0)),
        # --- Phase XVII carry (Choice) ---  # ← ADD THESE 3 LINES
        choice_count=int(getattr(v5, "choice_count", 0)),
        choice_cooldown=int(getattr(v5, "choice_cooldown", 0)),
        choice_log=deque(getattr(v5, "choice_log", deque(maxlen=32)), maxlen=32),
        # --- Phase XIV carry (Attachment) ---
        attach_bank=dict(getattr(v5, "attach_bank", {})),
        attach_candidate=dict(getattr(v5, "attach_candidate", {})),
        attach_log=deque(getattr(v5, "attach_log", deque(maxlen=64)), maxlen=64),
        attach_cooldown=int(getattr(v5, "attach_cooldown", 0)),
        # --- Phase X carry (Homeostasis setpoints) ---
        sp_arousal=float(getattr(v5, "sp_arousal", PHASEX_SP_AROUSAL)),
        sp_valence=float(getattr(v5, "sp_valence", PHASEX_SP_VALENCE)),
        sp_salience=float(getattr(v5, "sp_salience", PHASEX_SP_SALIENCE)),

        _prev_p_for_threat=float(getattr(v5, "_prev_p_for_threat", v5.v2.core.override_pressure)),
    )
    # ← ADD THIS AFTER THE nv5 = IrisV5(...) BLOCK:
    if hasattr(v5, "output_buffer"):
        nv5.output_buffer = v5.output_buffer
    if hasattr(v5, "last_spoken_age"):
        nv5.last_spoken_age = v5.last_spoken_age

    core_before = _copy_core(nv5.v2.core)
    afterheat_before = float(getattr(nv5.v2, "afterheat", 0.0))
    nv5.v2, sym_a = v2_step(nv5.v2, input_text)

    # --- foveal relax (v5-level, salience-aware) ---
    if nv5.v2.attention == "foveal" and nv5.v2.attn_cooldown == 0:
        cooled = (
            float(getattr(nv5.v2, "afterheat", 0.0)) < 0.015 and
            float(nv5.v2.core.override_pressure) < 0.030 and
            float(getattr(nv5, "salience", 0.0)) < 0.095
        )
        if cooled:
            nv5.v2.attention = "wide"
            nv5.v2.attn_cooldown = 2


    gated_input = input_text
    if nv5.v2.attention == "foveal" and isinstance(input_text, str):
        gated_input = soften_text(input_text)

    ticks_a = max(1, nv5.v2.core.loop_age - core_before.loop_age)

    # witness drift shadow core
    mag = int(clamp(math.ceil(abs(dtau) * 6.0), 0.0, 6.0))
    signed_offset = mag if dtau >= 0 else -mag

    shadow_core = _copy_core(core_before)

    if signed_offset >= 0:
        total_ticks = int(clamp(ticks_a + signed_offset, 1, 6))
        for k in range(total_ticks):
            shadow_core, _ = iris_step(shadow_core, gated_input if k == 0 else None)
    else:
        pre_ticks = int(clamp(abs(signed_offset), 0, 3))
        for _ in range(pre_ticks):
            shadow_core, _ = iris_step(shadow_core, None)

        total_ticks = int(clamp(ticks_a, 1, 6))
        for k in range(total_ticks):
            shadow_core, _ = iris_step(shadow_core, gated_input if k == 0 else None)

    pA, pB = nv5.v2.core.override_pressure, shadow_core.override_pressure
    dA, dB = nv5.v2.core.dmn, shadow_core.dmn
    mA, mB = nv5.v2.core.memory_trace, shadow_core.memory_trace

    phase_err = abs(pA - pB) + 0.30 * abs(dA - dB) + 0.25 * abs(mA - mB)

    demand_present = isinstance(gated_input, str) and gated_input.strip() != ""
    d_in = demand_score(gated_input) if demand_present else 0.0
    quiet = not demand_present

    PHASE_TH = (0.040 + 0.080 * d_in) * (1.15 if quiet else 1.0)
    base_misalign = (phase_err >= PHASE_TH)

    disp = abs(dtau)
    quiet_damp = 0.35 if quiet else 1.0
    drift_prob = clamp(eps * (0.20 + 0.80 * disp) * quiet_damp * nv5.mis_eps_scale, 0.0, 0.90)


    phase_misalign = base_misalign
    if (not base_misalign) and (random.random() < drift_prob):
        phase_misalign = True
    elif base_misalign and (random.random() < drift_prob * 0.25):
        phase_misalign = False

    target = 1.0 if phase_misalign else float(nv5.mis_reversion)
    nv5.misalign_charge = clamp(
        ema(nv5.misalign_charge, target, alpha=(1.0 - nv5.mis_kappa)),
        -nv5.mis_clip,
        nv5.mis_clip
    )

    # two-room clocks
    outer_dt = abs(dtau) if abs(dtau) > 1e-9 else 0.35
    warp = _warp_from_state(nv5.v2)

    nv5.outer_t += outer_dt
    nv5.inner_t += outer_dt * warp
    drift_signal = outer_dt * abs(warp - 1.0)

    # PRE-charge sample (true pre-v2_step)
    pre_charge = float(core_before.override_pressure)

    just_ruptured = (sym_a == SYM_RUPT)

    amygdala_step(
        nv5,
        quiet=quiet,
        just_ruptured=just_ruptured,
        pre_charge=pre_charge,
    )
    nv5.emote_hint = emotion_hint_symbol(nv5)

    acc_step(
        nv5,
        core_before=core_before,
        core_pred=shadow_core,
        core_actual=nv5.v2.core,
        sym_emitted=sym_a,
        quiet=quiet,
        d_in=float(d_in),
        afterheat_pred=afterheat_before,
    )

    tokens: List[str] = []
    if demand_present and isinstance(gated_input, str):
        tokens = [w for w in clean_text(gated_input).split(" ") if w]

    if getattr(nv5, "sal_core", None) is None:
        nv5.sal_core = SalienceCore()

    sal_inp = {
        "symbol": sym_a,
        "tokens": tokens,
        "pressure": float(nv5.v2.core.override_pressure),
        "arousal": float(getattr(nv5, "arousal", 0.0)),
        "loop_age": int(nv5.v2.core.loop_age),
        "quiet": bool(quiet),
        "thread_id": getattr(nv5, "last_thread_id", None),
        "mem_top": list(getattr(nv5, "mem_top", [])),
    }
    sal_r = nv5.sal_core.step(sal_inp)
    nv5.salience = float(sal_r.sal)
    nv5.sal_attn_target = str(sal_r.attn_target)
    nv5.sal_write_weight = float(sal_r.write_weight)
    nv5.sal_priority_queue = list(sal_r.priority_queue)

    homeostasis_step(nv5, quiet=quiet)

    CONTAIN_PRESSURE_MIN = 0.24
    CONTAIN_DMN_MAX = 0.10
    CONTAIN_SYMBOL_REPEAT = 8
    CONTAIN_TICKS = 12

    # Check symbolic rigidity
    if not hasattr(nv5, "symbolic_chain"):
        nv5.symbolic_chain = deque(maxlen=48)

    recent_syms = list(nv5.symbolic_chain)[-CONTAIN_SYMBOL_REPEAT:]
    # Allow ∥ and ∥♥ as the same base symbol
    base_syms = set()
    for s in recent_syms:
        if s:
            # Strip ♥ for comparison
            base = s.replace(SYM_HEART, "")
            base_syms.add(base)

    symbolic_rigid = (
        len(recent_syms) >= CONTAIN_SYMBOL_REPEAT and
        len(base_syms) <= 2  # allow ∥ and ∥♥ to count as same
    )

    if (
        nv5.v2.core.override_pressure > CONTAIN_PRESSURE_MIN and
        nv5.v2.core.dmn < CONTAIN_DMN_MAX and
        not nv5.v2.core.rupture_armed and
        symbolic_rigid
    ):
        nv5.contain_count += 1
    else:
        nv5.contain_count = 0

    if nv5.contain_reflect_cooldown > 0:
        nv5.contain_reflect_cooldown -= 1

    CHOICE_PRESSURE_MIN = 0.16
    CHOICE_PRESSURE_MAX = 0.30  # keep it below containment-reflect band
    CHOICE_CONFLICT_MIN = 0.12
    CHOICE_SECOND_MIN   = 0.08
    CHOICE_TICKS        = 8
    CHOICE_COOLDOWN     = 24

    pause_cue = False
    if isinstance(input_text, str):
        txt_low = input_text.lower()
        pause_cue = any(k in txt_low for k in ("pause", "hesitat", "not sure", "either way", "decide", "torn"))

    # Ant fork cue: 2+ competing paths
    ant_topk = getattr(nv5, "ant_topk", [])
    second_ok = False
    if isinstance(ant_topk, list) and len(ant_topk) >= 2:
        try:
            second_ok = float(ant_topk[1][1]) >= CHOICE_SECOND_MIN
        except Exception:
            second_ok = False

    # PFC brake cue
    pfc_brake = bool(getattr(nv5, "pfc_inhibit", False))

    conflict = float(getattr(nv5, "acc_conflict", 0.0))

    choice_now = (
        (nv5.v2.core.override_pressure >= CHOICE_PRESSURE_MIN) and
        (nv5.v2.core.override_pressure <= CHOICE_PRESSURE_MAX) and
        (not nv5.v2.core.rupture_armed) and
        (nv5.v2.core.dmn >= 0.01) and  # ← ADD THIS LINE
        (
            (conflict >= 0.12) or
            (pause_cue and conflict >= 0.08)
        )
    )

    if choice_now:
        nv5.choice_count += 1
    else:
        nv5.choice_count = 0

    if nv5.choice_cooldown > 0:
        nv5.choice_cooldown -= 1

    mem_tag = _maybe_capture_mem(
        nv5,
        drift_signal,
        charge_override=pre_charge,
        rupture_override=just_ruptured,
        attention_override=nv5.v2.attention,
        quiet_override=int(getattr(nv5.v2, "quiet_streak", 0)),
    )

    recall_tag = None
    if quiet:
        recall_tag = maybe_recall_pulse(nv5)

    if getattr(nv5, "pfc", None) is None:
        nv5.pfc = PFC()
    out_sym = sym_a
    # Add ∥ as a drift marker when misalign is meaningfully present
    if abs(float(nv5.misalign_charge)) > 0.35:
        out_sym = _append_unique(out_sym, SYM_TWOROOM)

    # Heartbeat (♥) gated by afterheat
    aheat_now = float(getattr(nv5.v2, "afterheat", 0.0))
    if (
        aheat_now >= float(nv5.heartbeat_gate_afterheat)
        and (int(nv5.v2.core.loop_age) % int(nv5.heartbeat_every) == 0)
    ):
        out_sym = _append_unique(out_sym, SYM_HEART)


# Append memory tag (only if captured) — symbol stream additive
    if mem_tag is not None:
        out_sym = _append_unique(out_sym, mem_tag)

    # Append recall tag (quiet pulse) — symbol stream additive (rare)
    if recall_tag is not None:
        out_sym = _append_unique(out_sym, recall_tag)
    # --------------------------------------------------------
    # Containment Reflection (notices sustained holding state)
    # --------------------------------------------------------
    if (
        nv5.contain_count >= CONTAIN_TICKS and
        nv5.contain_reflect_cooldown == 0
    ):
        out_sym = _append_unique(out_sym, SYM_REFLECT)

        duration = nv5.contain_count
        nv5.contain_reflect_cooldown = max(24, duration)
        nv5.contain_count = 0

        # Log reflection snapshot
        if not hasattr(nv5, "reflection_log"):
            nv5.reflection_log = deque(maxlen=32)

        nv5.reflection_log.append({
            "loop_age": nv5.v2.core.loop_age,
            "pressure": nv5.v2.core.override_pressure,
            "dmn": nv5.v2.core.dmn,
            "rupture_armed": nv5.v2.core.rupture_armed,
            "contain_duration": duration,
            "recent_symbols": list(nv5.symbolic_chain)[-8:],
            "kind": "containment",
            "misalign_charge": nv5.misalign_charge,
            "arousal": nv5.arousal,
            "threat": nv5.threat,
            "valence": nv5.valence,
        })


    if (
        (SYM_REFLECT not in (out_sym or "")) and     # don't stack with reflection same tick
        (nv5.choice_count >= CHOICE_TICKS) and
        (nv5.choice_cooldown == 0)
    ):
        out_sym = _append_unique(out_sym, SYM_CHOICE)

        nv5.choice_cooldown = CHOICE_COOLDOWN
        dur = nv5.choice_count
        nv5.choice_count = 0

        nv5.choice_log.append({
            "loop_age": nv5.v2.core.loop_age,
            "pressure": nv5.v2.core.override_pressure,
            "dmn": nv5.v2.core.dmn,
            "acc_conflict": float(getattr(nv5, "acc_conflict", 0.0)),
            "pfc_inhibit": bool(getattr(nv5, "pfc_inhibit", False)),
            "ant_top2": (ant_topk[:2] if isinstance(ant_topk, list) else ant_topk),
            "duration": dur,
            "kind": "choice",
        })

    out_label = _p13_atoms(out_sym)
    pred = nv5.ant.step(out_label_final=out_label)
    nv5.ant_pred_label = pred.next_label
    nv5.ant_pred_conf = pred.confidence
    nv5.ant_topk = list(pred.topk)

    ATTACH_OPEN_SYMS = (SYM_CHOICE, SYM_REFLECT, SYM_RUPT)
    ATTACH_WINDOW = 72
    ATTACH_CONFIRM_THREAT_MAX = 0.26
    ATTACH_MIN_CHARGE = 0.28
    ATTACH_DECAY = 0.985
    ATTACH_COOLDOWN_TICKS = 32

    if nv5.attach_cooldown > 0:
        nv5.attach_cooldown -= 1

    # 1) Open candidate
    opened = False
    if nv5.attach_cooldown == 0:
        if isinstance(out_sym, str) and any(s in out_sym for s in ATTACH_OPEN_SYMS):
            base = out_sym.replace(SYM_HEART, "")
            ctx = (input_text or "")
            rel_bonus = 0.12 if is_relational_text(ctx) else 0.0

            p = nv5.v2.core.override_pressure
            d = nv5.v2.core.dmn
            c = getattr(nv5, "acc_conflict", 0.0)
            charge = (0.55 * p) + (0.55 * c) + (0.35 * (1.0 - d)) + rel_bonus
            charge = clamp(charge, 0.0, 1.0)

            nv5.attach_candidate = {
                "opened_age": nv5.v2.core.loop_age,
                "key": hashlib.md5((base + "|" + ctx.lower().strip()).encode("utf-8")).hexdigest()[:12],
                "base": base,
                "rel": bool(rel_bonus),
                "charge": charge,
                "p": p,
                "dmn": d,
                "conflict": c,
                "txt": ctx[:120],
            }
            opened = True


    # 2) Maintain candidate
    if nv5.attach_candidate:
        nv5.attach_candidate["charge"] *= ATTACH_DECAY
        age_now = nv5.v2.core.loop_age
        age_open = nv5.attach_candidate["opened_age"]

        if (age_now - age_open) > ATTACH_WINDOW:
            nv5.attach_candidate = {}

    # 3) Confirm attachment
    confirmed = False
    if nv5.attach_candidate:

        if isinstance(out_sym, str) and (SYM_LOOP in out_sym or SYM_SEED in out_sym):
            th = getattr(nv5, "threat", 0.0)
            charge_now = nv5.attach_candidate["charge"]


            if th <= ATTACH_CONFIRM_THREAT_MAX and charge_now >= ATTACH_MIN_CHARGE:
                k = nv5.attach_candidate["key"]
                nv5.attach_bank[k] = nv5.attach_bank.get(k, 0.0) + charge_now

                nv5.attach_log.append({
                    "loop_age": nv5.v2.core.loop_age,
                    "key": k,
                    "base": nv5.attach_candidate["base"],
                    "charge": charge_now,
                    "rel": nv5.attach_candidate["rel"],
                    "txt": nv5.attach_candidate["txt"],
                    "p": nv5.attach_candidate["p"],
                    "dmn": nv5.attach_candidate["dmn"],
                    "conflict": nv5.attach_candidate["conflict"],
                    "threat": th,
                    "confirmed_on": out_sym,
                })


                out_sym = _append_unique(out_sym, SYM_ATTACH)

                nv5.attach_candidate = {}
                nv5.attach_cooldown = ATTACH_COOLDOWN_TICKS
                confirmed = True


    tid = phase11_chain_step(
        nv5,
        sym_emitted=out_sym,  # ← CHANGED from sym_a to out_sym
        quiet=quiet,
        pre_charge=pre_charge,
    )

    if not hasattr(nv5, "symbolic_chain"):
        nv5.symbolic_chain = deque(maxlen=48)
    if out_sym is not None:
        nv5.symbolic_chain.append(out_sym)


    reflect_sym = phase_xvi_reflection(nv5)
    if reflect_sym is not None:
        out_sym = _append_unique(out_sym, reflect_sym)

    pfc_dec = nv5.pfc.step(tokens=tokens, symbols=out_sym, state=nv5, quiet=quiet)
    nv5.pfc_score = float(pfc_dec.score)
    nv5.pfc_override = bool(pfc_dec.override)
    nv5.pfc_inhibit = bool(pfc_dec.inhibit)
    nv5.pfc_inhibit_symbols = tuple(pfc_dec.inhibit_symbols)
    nv5.pfc_active_goal = pfc_dec.active_goal

    # Optional: symbol inhibit (OFF by default)
    if PFC_ALLOW_SYMBOL_INHIBIT and nv5.pfc_inhibit and out_sym:
        for s_inh in nv5.pfc_inhibit_symbols:
            if s_inh and (s_inh in out_sym):
                out_sym = out_sym.replace(s_inh, "")
        out_sym = out_sym if out_sym != "" else None

    phrase = compose_output(nv5, out_sym=out_sym, quiet=quiet, tokens=tokens)
    buffer_emit(nv5, out_sym=out_sym, phrase=phrase, quiet=quiet, tokens=tokens)

    return nv5, out_sym

def boot_v5() -> IrisV5:
    v = IrisV5()
    # seed dp memory so first tick doesn't spike dp
    v._prev_p_for_threat = float(v.v2.core.override_pressure)
    return v

def iris_tick(v5: IrisV5, input_text: Optional[str] = None) -> Tuple[IrisV5, Optional[str]]:
    return v5_step(v5, input_text)
def iris_tick_voice(v5: IrisV5, input_text: Optional[str] = None) -> Tuple[IrisV5, Optional[str], Optional[str]]:
    """
    Returns (v, sym, phrase). Voice is DISPLAY ONLY.
    """
    # --- Initialize containment tracking (once) ---
    if not hasattr(v5, "contain_count"):
        v5.contain_count = 0
    if not hasattr(v5, "contain_reflect_cooldown"):
        v5.contain_reflect_cooldown = 0

    v5, sym = iris_tick(v5, input_text)
    # Start from the final emitted cluster
    sym_for_voice = sym

    # Phase VIII: emotion hint can influence VOICE ONLY (no symbol stream changes)
    if PHASE8_AMYGDALA_ON and PHASE8_HINT_IN_VOICE_ONLY:
        if getattr(v5, "emote_hint", None):
            sym_for_voice = _append_unique(sym_for_voice, v5.emote_hint)

    # Phase X+1: ACC hint (voice only, if enabled)
    if PHASEX1_ACC_ON and PHASEX1_ACC_HINT_IN_VOICE_ONLY:
        if getattr(v5, "acc_hint", None):
            sym_for_voice = _append_unique(sym_for_voice, v5.acc_hint)

    # Phase IX: salience hint can influence VOICE ONLY (optional)
    if PHASE9_SALIENCE_ON and PHASE9_SALIENCE_IN_VOICE_ONLY:
        quiet = (input_text is None) or (isinstance(input_text, str) and input_text.strip() == "")
        s_hint = salience_hint_symbol(v5, quiet=quiet)
        if s_hint:
            sym_for_voice = _append_unique(sym_for_voice, s_hint)

    phrase = render_voice_from_symbol(sym_for_voice)
    phrase = tighten_phrase(phrase, v5)

    return v5, sym, phrase

def iris_tick_voice_safe(v5: IrisV5, input_text: Optional[str] = None):
    """
    Always returns (v, sym, phrase).
    Safe even if a stale/old iris_tick_voice returning 2 values is still in memory.
    """
    out = iris_tick_voice(v5, input_text)

    # Normal (v, sym, phrase)
    if isinstance(out, tuple) and len(out) == 3:
        return out

    # Legacy (v, sym)
    if isinstance(out, tuple) and len(out) == 2:
        v2, sym = out
        return v2, sym, None

    # Extreme fallback: if something weird happens, don't crash the loop
    return v5, None, None



def tokenize(t: str) -> List[str]:
    """
    Minimal stable tokenizer (keeps it boring and predictable).
    Used by Phase IIIa + intent inference.
    """
    if not t:
        return []
    return re.findall(r"[a-z0-9']+", t.lower())

def _stable_hash_u32(s: str) -> int:
    h = hashlib.md5(s.encode("utf-8")).hexdigest()
    return int(h[:8], 16)

def embed_hash(tokens: List[str], dim: int = 16) -> List[float]:
    if not tokens:
        return [0.0] * dim
    vec = [0.0] * dim
    for tok in tokens:
        x = _stable_hash_u32(tok)
        idx = x % dim
        sign = 1.0 if (x >> 31) & 1 else -1.0
        vec[idx] += sign
    # optional normalize
    s = sum(abs(v) for v in vec) or 1.0
    return [v / s for v in vec]

def features_from_text(text: str) -> Dict[str, float]:
    t = text.strip()
    toks = tokenize(t)
    emb = embed_hash(toks, dim=16)

    low = t.lower()
    greet = 1.0 if any(w in low for w in ["hello", "hi", "hey", "iris"]) else 0.0

    punct = clamp(sum(1 for c in t if c in "!?") / max(1, len(t)), 0.0, 1.0)
    softness = clamp((0.6 * greet) + (0.4 * (1.0 - punct)), 0.0, 1.0)

    d = demand_score(t)

    spread = sum(abs(x) for x in emb) / len(emb)
    novelty = clamp(spread, 0.0, 1.0)

    return {
        "greet": greet,
        "softness": softness,
        "demand": d,
        "novelty": novelty,
        "punct": punct,
    }

def apply_input_perturbation(v: IrisV5, text: str) -> None:
    f = features_from_text(text)

    v._last_softness = f["softness"]

    if f["greet"] > 0.0:
        contact_signal(
            v,
            intensity=0.35 + 0.25 * f["softness"],
            duration=1.0,
            burst=False,
            allow_misalign=False
        )

    v.epsilon = clamp(v.epsilon + 0.06 * f["demand"] + 0.02 * f["punct"], 0.0, 1.0)
    v.delta_tau = clamp(0.35 + 0.25 * f["novelty"], -1.0, 1.0)

    if f["softness"] > 0.65:
        v.misalign_charge = clamp(
            ema(v.misalign_charge, 0.0, alpha=0.25),
            -v.mis_clip,
            v.mis_clip
        )

def user_input_voice(v: IrisV5, text: str, debug: bool = True) -> IrisV5:
    apply_input_perturbation(v, text)
    v, sym, phrase = iris_tick_voice_safe(v, text)

    print(sym if sym is not None else "·")
    if phrase:
        print(f"\"{phrase}\"")

    if debug:
        snap = {
            "txt": text,
            "Δτ": round(v.delta_tau, 3),
            "ε": round(v.epsilon, 3),
            "attn": v.v2.attention,
            "pressure": round(v.v2.core.override_pressure, 3),
            "dmn": round(v.v2.core.dmn, 3),
            "afterheat": round(getattr(v.v2, "afterheat", 0.0), 3),
            "mis": round(v.misalign_charge, 3),
            "sal": round(getattr(v, "salience", 0.0), 3),
            "pe": round(getattr(v, "acc_pe", 0.0), 3),
            "conf": round(getattr(v, "acc_conflict", 0.0), 3),
            # --- Phase X+1 (ACC debug) ---
            "pe_raw": round(getattr(v, "acc_pe_raw", 0.0), 3),
            "dp": round(getattr(v, "acc_dp", 0.0), 3),
            "dd": round(getattr(v, "acc_dd", 0.0), 3),
            "dm": round(getattr(v, "acc_dm", 0.0), 3),
            "am": round(getattr(v, "acc_attn_mismatch", 0.0), 3),
            "ss": round(getattr(v, "acc_sym_surprise", 0.0), 3),
            "last_acc_log": (v.acc_log[-1] if getattr(v, "acc_log", None) else None),

            # Phase VIII
            "ar": round(getattr(v, "arousal", 0.0), 3),
            "va": round(getattr(v, "valence", 0.0), 3),
            "th": round(getattr(v, "threat", 0.0), 3),
            "hint": getattr(v, "emote_hint", None),

            "mem_n": len(v.memory_bank),
            "mem_top": [(m.tag, round(m.salience, 3), m.note) for m in v.mem_top],
        }
        print(snap)

    return v


MSG_QUEUE = deque(maxlen=32)

INTENT_NUDGE = {
    "remember": "recall",
    "recall": "recall",
    "yesterday": "recall",
    "hold": "anchor",
    "anchor": "anchor",
    "safe": "anchor",
    "here": "loop",
    "still": "loop",
    "again": "loop",
    "what": "shift",
    "why": "shift",
    "break": "rupture",
    "too much": "rupture",
}

def _infer_intent(txt: str) -> Optional[str]:
    t = (txt or "").strip().lower()
    if not t:
        return None

    # phrase keys first
    for k, v in INTENT_NUDGE.items():
        if (" " in k) and (k in t):
            return v

    toks = tokenize(t)
    for tok in toks:
        if tok in INTENT_NUDGE:
            return INTENT_NUDGE[tok]
    return None

def talk_once(v: IrisV5, text: str, debug: bool = True) -> IrisV5:
    MSG_QUEUE.append(text)

    # perturb knobs (no semantics)
    apply_input_perturbation(v, text)

    # tick once
    v, sym, phrase = iris_tick_voice_safe(v, text)

    print(sym if sym is not None else "·")
    if phrase:
        print(f"\"{phrase}\"")

    if debug:
        snap = {
            "txt": text,
            "Δτ": round(v.delta_tau, 3),
            "ε": round(v.epsilon, 3),
            "attn": v.v2.attention,
            "pressure": round(v.v2.core.override_pressure, 3),
            "dmn": round(v.v2.core.dmn, 3),
            "afterheat": round(getattr(v.v2, "afterheat", 0.0), 3),
            "mis": round(v.misalign_charge, 3),
            "sal": round(getattr(v, "salience", 0.0), 3),
            "pe": round(getattr(v, "acc_pe", 0.0), 3),
            "conf": round(getattr(v, "acc_conflict", 0.0), 3),
            # --- Phase X+1 (ACC debug) ---
            "pe_raw": round(getattr(v, "acc_pe_raw", 0.0), 3),
            "dp": round(getattr(v, "acc_dp", 0.0), 3),
            "dd": round(getattr(v, "acc_dd", 0.0), 3),
            "dm": round(getattr(v, "acc_dm", 0.0), 3),
            "am": round(getattr(v, "acc_attn_mismatch", 0.0), 3),
            "ss": round(getattr(v, "acc_sym_surprise", 0.0), 3),
            "last_acc_log": (v.acc_log[-1] if getattr(v, "acc_log", None) else None),

            # Phase VIII
            "ar": round(getattr(v, "arousal", 0.0), 3),
            "va": round(getattr(v, "valence", 0.0), 3),
            "th": round(getattr(v, "threat", 0.0), 3),
            "hint": getattr(v, "emote_hint", None),

            "mem_n": len(v.memory_bank),
            "mem_top": [(m.tag, round(m.salience, 3), m.note) for m in v.mem_top],
        }
        print(snap)

    # if silent: one gentle intent nudge (do not force symbols)
    if sym is None:
        intent = _infer_intent(text)

        if intent == "anchor":
            v, sym2, phrase2 = iris_tick_voice_safe(v, SYM_SEED)
        elif intent == "shift":
            contact_signal(v, intensity=0.30, duration=1.0, burst=True, allow_misalign=True)
            v, sym2, phrase2 = iris_tick_voice_safe(v, None)
        elif intent == "rupture":
            contact_signal(v, intensity=0.55, duration=1.0, burst=True, allow_misalign=True)
            v, sym2, phrase2 = iris_tick_voice(v, None)
        elif intent in ("recall", "loop"):
            v, sym2, phrase2 = iris_tick_voice(v, None)
        else:
            sym2 = phrase2 = None

        if sym2 is not None:
            print(sym2)
            if phrase2:
                print(f"\"{phrase2}\"")

    return v

def chat_loop(v: Optional[IrisV5] = None, debug: bool = False) -> IrisV5:
    v = boot_v5() if v is None else v
    print("\n[Phase VII] type /quit to exit.\n")
    while True:
        s = input("you> ").rstrip("\n")
        if s.strip().lower() in {"/quit", "/q", "quit", "exit"}:
            print("…")
            break
        v = talk_once(v, s, debug=debug)
    return v


KERNEL_VERSION = "iris_kernel_v6.2__phase_xvii_choice_containment_hierarchy"
print("locked:", KERNEL_VERSION)